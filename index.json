{
  "articles/configs/index.html": {
    "type": "article",
    "href": "articles/configs/index.html",
    "title": "Config files in alt:V",
    "keywords": "Improve this Doc Config files in alt:V This article will explain the different types of config files and the use of config files in alt:V. What are config files used for Config files are the files that give alt:V information about your server configuration. In a config file you specify e.g. your server name, the amount of slots, the type of your resource etc. There are several different config files in alt:V, which all have their own set of configuration options, usage and location. Important rules about the config files Every line only contains one configuration option Every configuration option is a key value pair, so it starts with the key , then a : to seperate the key and the value, and after that the value Lines are ended with a linebreak, commas at the end of every line are optional Strings don't need to be inclosed in \" or ' , only when they contain special characters like , for example Lines that start with a hashtag ( # ) are ignored and can be used for comments Empty lines are ignored For advanced users If you want to see for yourself how the config files get parsed or even want to use the config files that alt:V uses yourself, you can take a look at the GitHub repository for it. The config solution alt:V uses is a single C/C++ header file, so you should keep in mind that you probably need some experience in the C programming language if you want to take a look at the source code of it yourself.",
    "langs": ""
  },
  "articles/configs/resource.html": {
    "type": "article",
    "href": "articles/configs/resource.html",
    "title": "The resource.cfg configuration file",
    "keywords": "Improve this Doc The resource.cfg configuration file The resource.cfg configuration file is needed for every resource you have, it has to be located in the main directory of your resource. It has some configuration options for your resource like the type of your resource and its dependencies. Here is a list of all configuration options for the resource.cfg and what they are used for: # The serverside type of your resource (the correct module for that type has to be loaded) type: \"js\" # The clientside type of your resource (the correct module for that type has to be loaded) client-type: \"js\" # The main serverside file that will get loaded when the server starts main: \"server.js\" # The main clientside file that will get loaded when the client starts client-main: \"client.js\" # The files that the client has access to (The client-main file does not have to be included here) client-files: [ \"myFile.js\", # You can also use glob patterns to give access to a whole directory \"client/*\" ] # The required permissions to play on the server (these have to be accepted, otherwise the player can't join) required-permissions: [ \"Screen Capture\" ] # The optional permissions to play on the server (these permissions can be declined by the user) optional-permissions: [ \"WebRTC\" ] # The dependencies of this resource (All dependencies get loaded before the resource) deps: [ \"myOtherResource\" ]",
    "langs": "yaml"
  },
  "articles/configs/server.html": {
    "type": "article",
    "href": "articles/configs/server.html",
    "title": "The server.cfg configuration file",
    "keywords": "Improve this Doc The server.cfg configuration file The server.cfg file is the most important configuration file, it is the main configuration file for your whole server, and will define important configurations like server name, amount of slots, loaded resources and more. Here is a list of all configuration options for the server.cfg and what they are used for: # The display name of your server name: \"My server name\" # The binding address of your server (usually 0.0.0.0) host: \"0.0.0.0\" # The port of your server (default 7788) port: 7788 # The amount of players that can play on your server concurrently players: 1000 # The password required to join your server password: \"mySecretPassword\" # If the server should be visible on the masterlist in the alt:V client announce: true # The gamemode your server is running gamemode: \"Freeroam\" # The website of your server website: \"example.com\" # The language of your server language: \"English\" # The description of your server description: \"My cool server\" # If the debug mode should be allowed (Debug mode allows debugging functions like reconnect or the CEF debugger) debug: false # The stream in distance for entities streamingDistance: 1500 # The migration distance for entities migrationDistance: 150 # The timeout multiplier (must be >= 1) timeout: 1 # An array of all modules that should be loaded modules: [ \"js-module\", \"csharp-module\", \"lua-module\" ] # An array of all resources that should be loaded resources: [ \"myResource\" ] # Voice configuration (needs to be set to enable voice chat) voice: { # The bitrate of the voice server bitrate: 64000, # The secret for the external server (only needed when using externalHost) externalSecret: \"secret123\", # The external host address externalHost: \"127.0.0.1\", # The external host port externalPort: 7798, # The external host public address (should be the ip address of your server) externalPublicHost: \"127.0.0.1\", # The external host public port externalPublicPort: 7799 } # The tags for your server (max. 4) tags: [ \"Freeroam\", \"Cool\" ] # Should early auth be used for your server useEarlyAuth: true # The url for the early auth login page (only used when useEarlyAuth is true) earlyAuthUrl: \"https://example.com/login\" # Should a CDN be used for your server useCdn: true # The url for the CDN page cdnUrl: \"https://cdn.example.com\"",
    "langs": "yaml"
  },
  "articles/configs/stream.html": {
    "type": "article",
    "href": "articles/configs/stream.html",
    "title": "The stream.cfg configuration file",
    "keywords": "Improve this Doc The stream.cfg configuration file The stream.cfg configuration file is needed for every dlc resource, e.g. a new vehicle. It has some configuration options like the GXT values and meta files. Here is a list of all configuration options for the stream.cfg and what they are used for: # An array containing all files that should be loaded for this dlc files: [ # You can also use glob patterns to give access to a whole directory \"stream/assets/*\" ] # The meta files your dlc uses meta: { \"stream/carcols.meta\": CARCOLS_FILE, \"stream/vehicles.meta\": VEHICLE_METADATA_FILE, \"stream/handling.meta\": HANDLING_FILE } # The GXT entries for your dlc gxt: { \"myveh\": \"My vehicle\" }",
    "langs": "yaml"
  },
  "articles/contributing.html": {
    "type": "article",
    "href": "articles/contributing.html",
    "title": "How to Contribute",
    "keywords": "Improve this Doc How to Contribute This document includes a set of guidelines for contributing to alt:V documentation. Table of Contents Documentation structure Linked repositories Build tools Initial setup Generating and testing Creating articles Publishing your work Documentation structure Structure consists of one or more repositories linked to the core repository (you're currently in it). Core repository is responsible for including linked repositories in documentation generation process. We're using DocFx generator for that task. Each linked repository have directory structure that looks similar to this: └───docs │ build.cmd │ build.ps1 │ docfx.json │ index.md │ toc.yml │ ├───api └───articles docfx.json is the main configuration file, used locally for testing purposes. If you wish to learn more about its format, refer to this . build.cmd and build.ps1 are scripts written in PowerShell to test documentation locally before publishing changes to core repository. Later we'll explain how they work and how to use them. index.md and toc.yml are main Conceptual documents that are required (with some exceptions) in documentation. toc.yml file (Table of Contents or ToC) is YAML document that specifies documentation structure in current directory and is responsible for linking other subdirectories for ease of navigation. If you wish to learn more about its format, refer to this article . index.md file is Markdown document that appear in every directory and serves as a starting page. api contains API documentation, which is mostly generated automatically from source code of the project and later incorporated by documentation generator. When generated automatically, we don't edit these files directly, but we use files called overwrite documents, which allows us to overwrite files without editing source at all. articles contains Conceptual documentation, which will be the place where you'll spend the most of your time. In the opposition to api folder, files there are created manually by contributors. Linked repositories We include community created modules in our documentation and if you want to contribute to language specific documentation, switch to repository posted below: Language Repository JS https://github.com/altmp/altv-types C# https://github.com/FabianTerhorst/coreclr-module Lua https://github.com/drakeee/altv-lua-module Build tools As mentioned previously, every linked repository should contain build tools to easily test and verify your work. As of now, we're only providing ways to do that on Windows, where PowerShell is installed. Warning Other operating systems are not supported by us and by current documentation generator (although it might change in DocFx v3). Actual code is defined in build.ps1 , where build.cmd serves as wrapper (by default in Windows Explorer it's not allowed to execute PowerShell scripts by simply opening them). Command-line arguments: Argument Description Usage port Changes port used by DocFx to host website on. ./build.ps1 -port 80 cleanMetadata All generated output will be removed on each run. ./build.ps1 -cleanMetadata cleanOnly All dependencies will be removed only. ./build.ps1 -cleanOnly Initial setup To start adventure with contribution, you need programs installed such as Git, Node with npm package manager and if you wish to work with C# documentation, Visual Studio with \".NET desktop development\" workload or Visual Studio Build Tools with \".NET Desktop build tools\" workload. Fork the repository - https://github.com/altmp/altv-docs/fork Open a terminal on Windows. Move to the directory that you want to work in. Clone your repository, replace USER with your GitHub username: git clone https://github.com/USER/altv-docs Add the altmp/altv-docs repo as a remote repository git remote add upstream https://github.com/altmp/altv-docs Switch to the docs directory if there's one in your forked repository. It should have files as described in documentation structure. Generating and testing When build.ps1 script is executed, first we download dependencies such as DocFx tool, plugins, templates or linked repositories etc. Warning Keep in mind that currently we don't automatically update dependencies, but manually deleting them should trigger redownload. Next thing is project metadata generation, which is needed for API documentation. Lastly, DocFx build is executed and generated site will be available on localhost:8080 by default. To stop running script or update website with newest changes, simply terminate running script by pressing key combination Ctrl+C . After that, you can execute script again if needed. If everything works to this moment, you can now start contributing. Tip It's highly recommended that you should work on separate branch rather than master , so you can easily incorporate changes when repository gets updated. Creating articles Before you start creating/editing files, you should think about what you want to add first. Warning You can't write articles about GTA:V stuff, like modding, data etc. That stuff belongs to our wiki website. Title should be as short as possible, understandable and preferably catchy. Another thing to do is to choose proper category for your article. You should find available ones in articles/ directory, they look like folders. Now, if you plan on making only single article, you can go to step Single article . If not, you've to create category for them in case you haven't found one. Follow instructions defined in step Article series . Article series Just like before, you've to think of the name for your category and it also should be as short as possible, understandable and preferably catchy (also it can't be the same as article name). When you got one, create new folder with that name in articles/ directory. Tip Remember, name should be lowercase, alphanumeric and spaces should be replaced with hyphen. You can go inside that folder and create two files there named index.md and toc.yml . These files are required, though index.md can stay empty for now. Before we'll focus on making actual articles, we've to make your category visible in Table of Contents. Let's open articles/toc.yml file, which now looks similar to this: - name: Getting Started href: getting-started/ topicHref: getting-started/index.md - name: How to Contribute href: contributing.md We'll copy Getting Started item and append it just below with changed details. Caution Make sure that How to Contribute item is always at the bottom. Before: - name: Getting Started href: getting-started/ topicHref: getting-started/index.md - name: How to Contribute href: contributing.md After: - name: Getting Started href: getting-started/ topicHref: getting-started/index.md - name: Fancy Category href: fancy-category/ topicHref: fancy-category/index.md - name: How to Contribute href: contributing.md If you've done everything correctly to this point, your category should now be visible. Let's go back to our index.md file created earlier. Index file in our category should contain short summary and what articles are featured. Now we can move on to next step below. Single article Now you can create file in articles/ directory (or in your category directory) with title as filename and .md extension. Tip Remember, filename should be lowercase, alphanumeric and spaces should be replaced with hyphen. Now that file will be included in generation process, but it's not visible in Table of Contents (also abbreviated as ToC) yet. To happen so, we need to add new entry in toc.yml file in the same directory, so your file will be fully visible. Before: - name: Getting Started href: getting-started/ topicHref: getting-started/index.md - name: How to Contribute href: contributing.md After: - name: Getting Started href: getting-started/ topicHref: getting-started/index.md - name: Fancy Article href: fancy-article.md - name: How to Contribute href: contributing.md In case you're creating article series , your toc.yml file is more likely empty at the moment. You don't need to copy code above, you'll only need to add new item. Now we can switch to our file content and first text which will be title formatted as Heading 1 . Example: # Contribution ... content here ... If you encounter trouble with Markdown, you can refresh your memory here . Publishing your work Once you have finished working on your changes, you can submit a pull request to have your changes merged into the repository and included in the documentation. Before submitting a pull request, make sure that you've verified your work. If you've doubts or need help with something, feel free to ask in alt:V Discord server #scripting-offtopic .",
    "langs": "bash yaml md"
  },
  "articles/getting-started/index.html": {
    "type": "article",
    "href": "articles/getting-started/index.html",
    "title": "This page isn't ready yet",
    "keywords": "Improve this Doc This page isn't ready yet",
    "langs": ""
  },
  "articles/index.html": {
    "type": "article",
    "href": "articles/index.html",
    "title": "This page isn't ready yet",
    "keywords": "Improve this Doc This page isn't ready yet",
    "langs": ""
  },
  "articles/logging.html": {
    "type": "article",
    "href": "articles/logging.html",
    "title": "Logging in alt:V",
    "keywords": "Improve this Doc Logging in alt:V This article will explain the usage of logging in alt:V. It will explain the concept of logging, the different types of logging and how to use logging in alt:V. What is logging used for As a programmer, logging is very important for debugging and showing information. By logging to the console, you can check the values of variables etc. at runtime to find your bug or optimize your code. Important things to know about logging Don't use logging in production too much, because it can lag the console and will also hide the important logs you have placed. It is best to completely disable logging on the client in the production, and setting logging to the bare minimum (e.g. only errors) on the server. Also don't put any sensitive information into your logs, the logs get saved to a file in plain text, so logging e.g. a password to the console is a big security risk. When and how to use logging There are different types of logging, which should be used for different kinds of logs. You can see a table of the different types of logs here: Type Usage Infos To display general information about something Warnings To display something maybe being wrong, but not being very important Errors To display something going very wrong, which needs immediate action Using colors in logs If you want to make your log messages look better, you can use different color codes to highlight important parts of the message. Or to group/categorize your logs better. The color codes can be used by appending a color code, like this for example: ~r~ , before your part of the text that should have that color. You can see a list of all color codes in the table below: Color code Screenshot ~k~ ~r~ ~g~ ~b~ ~y~ ~m~ ~c~ ~w~ ~lk~ ~lr~ ~lg~ ~lb~ ~ly~ ~lm~ ~lc~ ~lw~ Using logs in your code Here you can find small examples in the different programming languages alt:V offers on how to use logging: JavaScript / Lua alt.log(\"~r~Hello ~g~World!\"); alt.logWarning(\"This is a warning\"); alt.logError(\"This is an error\"); C# ColoredMessage coloredMessage = new ColoredMessage(); coloredMessage += TextColor.Red; coloredMessage += \"Hello \"; coloredMessage += TextColor.Green; coloredMessage += \"World!\"; Alt.LogColored(coloredMessage); Alt.LogWarning(\"This is a warning\"); Alt.LogError(\"This is an error\"); Alt.LogInfo(\"This is an info\"); Alt.LogDebug(\"This is a debug message\");",
    "langs": "js csharp cs"
  },
  "cs/api/index.html": {
    "type": "article",
    "href": "cs/api/index.html",
    "title": "AltV.Net C# Api Documentation",
    "keywords": "Improve this Doc AltV.Net C# Api Documentation",
    "langs": ""
  },
  "cs/articles/async.html": {
    "type": "article",
    "href": "cs/articles/async.html",
    "title": "Async Module",
    "keywords": "Improve this Doc Async Module This article will talk about how to use altv's thread safe. All techniques described in this article will only work when you extend AsyncResource. Setup async module First download the nuget package to access the async api's. https://www.nuget.org/packages/AltV.Net.Async Next you need to inherit from AsyncResource instead of Resource . Now you can use the async module. Async event handlers You can register a async event handler when using AltAsync instead of Alt for registering event handlers like AltAsync.OnPlayerConnect += async (player, reason) => { Console.WriteLine($\"{player.Name} connected.\"); await DoAsyncStuff(player); }; Use apis thread safe All api's related to entities like Player, Vehicle, Blip, ColShape, Checkpoint, VoiceChannel are not thread safe and will make your server crash when used wrong in async code. How to use most apis thread safe without performance loose? You can get the position of a player in async code by preventing the player entity to get deleted while accessing the position. This doesn't work with all apis Small example: Position position; lock (player) { if (player.Exists) { position = player.Position } } Console.WriteLine(\"X:\" + position.X); Lets breakdown the small code snippet. Position position; We create a value to save the position into; lock (player) We lock the player to prevent access to it from multiple c# threads at the same time. This also prevents the c# module to delete the player on disconnect. Otherwise the server would end up crashing by accessing the player position of a deleted entity. Note: locking the player when its already locked will end up in a deadlock. Never do this E.g. lock (player) { lock (player) { } } Locks also work accross method calls so be careful. if (player.Exists) { This if check is optional, because not checking it won't crash the server, but will throw a exception when the player doesn't exist anymore. position = player.Position Here we assign the position to the value we declared above. This is essential because no heavy calculations should happen inside a lock statement and the assign makes it possible to use the player position outside the lock statement for e.g. distance calculatione. How to use all apis thread safe A few apis aren't possible to use thread safe from a different thread. To use those apis we have to execute them on main thread. To make this easy for serverdev AltAsync has a method to do just this. Here is a example. var vehicle = await AltAsync.Do(() => Alt.CreateVehicle(VehicleModel.T20, player.Position, player.Rotation)); This example only works when called inside a method that is declared async. AltAsync.Do will execute any code inside of it on the main thread. And will return the result when its awaited. You can also use AltAsync.Do when you don't care about the result and about the execution order. When you need to call multiple apis at once don't do multiple AltAsync.Do when possible. Otherwise it may create a overhead on the main thread. var vehicle = await AltAsync.Do(() => { var vehicle = Alt.CreateVehicle(VehicleModel.T20, player.Position, player.Rotation); var vehicle2 = Alt.CreateVehicle(VehicleModel.Chimera, player.Position, player.Rotation); }); Threadsafe methods from AltV.Net.Alt Entity pools The AltV.Net.Async.AltAsync class does not provide methods to interact with entity pools/lists. If you are using an AsyncResource , the methods for entity pooling on AltV.Net.Alt are overwritten and are threadsafe to use. This includes the following methods: public override IBaseEntityPool GetBaseEntityPool(IEntityPool<IPlayer> playerPool, IEntityPool<IVehicle> vehiclePool); public override IBaseObjectPool<IBlip> GetBlipPool(IBaseObjectFactory<IBlip> blipFactory); public override IBaseObjectPool<ICheckpoint> GetCheckpointPool(IBaseObjectFactory<ICheckpoint> checkpointFactory); public override IBaseObjectPool<IColShape> GetColShapePool(IBaseObjectFactory<IColShape> colShapeFactory); public override IEntityPool<IPlayer> GetPlayerPool(IEntityFactory<IPlayer> playerFactory); public override IEntityPool<IVehicle> GetVehiclePool(IEntityFactory<IVehicle> vehicleFactory); public override IBaseObjectPool<IVoiceChannel> GetVoiceChannelPool(IBaseObjectFactory<IVoiceChannel> voiceChannelFactory); as they are overwritten in the AsyncResource class.",
    "langs": "csharp cs"
  },
  "cs/articles/async-colshapes.html": {
    "type": "article",
    "href": "cs/articles/async-colshapes.html",
    "title": "This page isn't ready yet",
    "keywords": "Improve this Doc This page isn't ready yet",
    "langs": ""
  },
  "cs/articles/build-in-events.html": {
    "type": "article",
    "href": "cs/articles/build-in-events.html",
    "title": "This page isn't ready yet",
    "keywords": "Improve this Doc This page isn't ready yet",
    "langs": ""
  },
  "cs/articles/checkpoints.html": {
    "type": "article",
    "href": "cs/articles/checkpoints.html",
    "title": "Introduction",
    "keywords": "Improve this Doc Introduction Checkpoints are very similiar to Colshapes. The main difference is that Checkpoints are displayed on clients (e.g. as arrow), while colshapes are invisible and designed for detecting collisions. Important to know is that the internal streaming of checkpoints is not optimized and you should use them as less as possible. With checkpoints you are able to detect appearing or disappearing entities of an area, specified by position, radius and height. The specified checkpoint type defines the shape of the checkpoint (there are 3 shapes available: Cylinder, Rings, Arrows). Typical usages of checkpoints are parkour racings or driving/flying tutorials. alt:V offers full API support for creating Checkpoints on serverside. API Methods Method Description Alt.CreateCheckpoint Creates a new checkpoint Alt.ForEachCheckpoint Iterates through all created checkpoints Alt.GetAllCheckpoints Returns all created checkpoints as ICollection<ICheckpoint> Alt.GetCheckpointsArray Returns all created checkpoints as KeyValuePair<IntPtr,ICheckpoint>[] Alt.RemoveCheckpoint Destroys the specified checkpoint Events Alt.OnCheckpoint is raised whenever any checkpoint is entered by any player. Inside of the event handler you need to check which one of your checkpoints got triggered by comparing the object instances with the first parameter. The entity which raised the event is specified by the second parameter. At last state defines if the entity entered ( true ) or left ( false ) the checkpoint area. Full example using AltV.Net; using AltV.Net.Elements.Entities; using System.Drawing; public class CheckpointTest : IScript { private ICheckpoint _demoCheckpoint; public CheckpointTest() { // register event handler Alt.OnCheckpoint += Alt_OnCheckpoint; // create a new checkpoint _demoCheckpoint = Alt.CreateCheckpoint(CheckpointType.Cyclinder, new Position(), 1.5f, 2f, Color.Yellow); } private void Alt_OnCheckpoint(ICheckpoint checkpoint, IEntity entity, bool state) { if (checkpoint != _demoCheckpoint) { return; } if (state) { // entity entered the checkpoint } else { // entity left the checkpoint } } }",
    "langs": "csharp cs"
  },
  "cs/articles/colshapes-example.html": {
    "type": "article",
    "href": "cs/articles/colshapes-example.html",
    "title": "ColShape Example",
    "keywords": "Improve this Doc ColShape Example This is a example how to create a collision sphere & call it. Parameter Description shape The colshape which got triggered. entity The entity who triggered the colshape. state The entering status ( true = entered, false = left ). Normal event handler Alt.OnColShape += (shape, entity, state) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript class! Otherwise it won't work! // We declare & create our colsphere. IColShape col = Alt.CreateColShapeSphere(new Vector3(0, 0, 0), 3.0f); // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.ColShape)] public static void OnEntityColshapeHit(IColShape shape, IEntity entity, bool state) { // We create our switch statement. string stateMsg = state switch { true => \"entered\", _ => \"left\" }; switch (entity) { case IPlayer player: player?.SendChatMessage(\"You \" + stateMsg + \" a colshape!\"); break; case IVehicle vehicle: vehicle?.Driver?.SendChatMessage(\"You \" + stateMsg + \" a colshape with your \"+ (VehicleModel)vehicle.Model +\"!\"); break; } } ColShape Type´s Here are all colshape types. ColShape in a Circle form. //Parameter : (Vector3 pos, float Radius) Alt.CreateColShapeCircle(new Vector3(0, 0, 0), 1.0f); // Creates a colshape in a form of a circle. ColShape in a Cube form. //Parameter : (Vector3 pos1, Position pos2) Alt.CreateColShapeCube(new Vector3(0, 0, 0), new Vector3(0, 0, 0)); // Creates a colshape in a form of a cube. ColShape in a Cylinder form. //Parameter : (Vector3 pos, float radius, float height) Alt.CreateColShapeCylinder(new Vector3(0, 0, 0), 1.0f, 100f); // Creates a colshape in a form of a cylinder. ColShape in a Rectangle form. //Parameter : (float x1, float y1, float x2, float y2, float height) Alt.CreateColShapeRectangle(0.0f, 0.0f, 0.0f, 0.0f, 10f); // Creates a colshape in a form of a rectangle.",
    "langs": "csharp cs"
  },
  "cs/articles/create-resource.html": {
    "type": "article",
    "href": "cs/articles/create-resource.html",
    "title": "Create Resource",
    "keywords": "Improve this Doc Create Resource Create a project with Visual Studio 19 (Windows) Go to \"File -> New -> Project...\" now the Project Wizard should appear. In the left Column select \"Installed -> Visual C# -> .NET Core\". Now select \"Class Library (.NET Core)\" and choose \"Name\", \"Location\" and the \"Solution name\". To setup the correct NuGet Packages open the Manager under \"Tools -> NuGet Package Manager -> Manage NuGet Packages for Solution...\" Select Browse and search for AltV.Net and install the packages \"AltV.Net\", (\"AltV.Net.Async\" when you need async thread save api access) Now go to \"Project -> {Your Project Name} Properties... -> Build\", here you can select the Output path where the dll should be saved. See https://docs.microsoft.com/en-us/visualstudio/deployment/quickstart-deploy-to-local-folder?view=vs-2019 for automatically publish it in your resource folder or see the boilerplate project file. Boilerplate YourProject.csproj: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>netcoreapp3.0</TargetFramework> </PropertyGroup> <ItemGroup> <!--Use latest version from https://www.nuget.org/packages/AltV.Net--> <PackageReference Include=\"AltV.Net\" Version=\"1.13.0\" /> </ItemGroup> <!--This copies the publish directory to the resource folder which is named \"my-server\"--> <ItemGroup> <AllOutputFiles Include=\"$(OutputPath)\\publish\\*.*\" /> </ItemGroup> <Target Name=\"CopyFiles\" AfterTargets=\"publish\"> <PropertyGroup> <CopiedFiles>$(OutputPath)\\publish\\*.*</CopiedFiles> <TargetLocation Condition=\" '$(Configuration)' == 'Release' \">../../my-server/</TargetLocation> </PropertyGroup> <Copy Condition=\" '$(TargetLocation)' != '' \" SourceFiles=\"@(AllOutputFiles)\" DestinationFolder=\"$(TargetLocation)\" SkipUnchangedFiles=\"false\" /> </Target> </Project> You now have to create a single resource file in your project that is auto initialized on server startup. MyResource.cs using System; namespace My.Package { internal class MyResource : Resource { public override void OnStart() { Console.WriteLine(\"Started\"); } public override void OnStop() { Console.WriteLine(\"Stopped\"); } } } Compile the resource To compile the resource from the command line use dotnet publish -c Release This will output the resource dll and all other dependencies including AltV.Net.dll in the yourresource/bin/Release/netcoreapp3.0/publish folder. Copy the dlls to the server resource folder altv-server/resources/{YourResourceName}/ . To get the Resource running on the server, you have to create a \"resource.cfg\" file. type: \"csharp\", main: \"YourProject.dll\" Now the resource needs to be added to the server.cfg. resources: [ \"{YourResourceName}\" ] Your server folder now look similar to this one modules/ └── csharp-module.dll resources/ └── my-example-csharp-resource/ ├── Alt.Net.Example.dll ├── resource.cfg └── ... (any .dll dependency like \"AltV.Net.dll\", \"mysql.dll\", ...) AltV.Net.Host.dll AltV.Net.Host.runtimeconfig.json server.cfg altv-server.exe For creating scripts that can be created multiple times see: Create script .",
    "langs": "csharp cs"
  },
  "cs/articles/create-script.html": {
    "type": "article",
    "href": "cs/articles/create-script.html",
    "title": "Create Script",
    "keywords": "Improve this Doc Create Script Make sure you have created a resource before. Classes that extend IScript are getting auto initiaized. MyScript.cs using System; namespace My.Package { public class MyScript : IScript { } } Scripts can register event handlers via method attributes. For adding a player connect handler. The method name doesn't matter for script events. [ScriptEvent(ScriptEventType.PlayerConnect)] public void PlayerConnect(IPlayer player, string reason) { player.SetDateTime(DateTime.Now); player.Model = (uint) PedModel.FreemodeMale01; } For adding a custom event handler. The method name is used as a event name when its not defined in the attribute. // Here the event name is 'MyEventName' and the event handler receives server events [ServerEvent(\"MyEventName\")] public static void MyEventName2(string message) { Console.WriteLine(message); } // Here the event name is 'MyCustomEvent' and the event handler receives server events [ServerEvent] public static void MyCustomEvent(string message) { Console.WriteLine(message); } // Here the event name is 'MyClientEventName' and the event handler receives client events [ClientEvent(\"MyClientEventName\")] public static void MyClientEventName2(string message) { Console.WriteLine(message); } // Here the event name is 'MyClientCustomEvent' and the event handler receives client events [ClientEvent] public static void MyClientCustomEvent(string message) { Console.WriteLine(message); } The ScriptEvent method signatures are the same as the signatures used when registering the events via Alt.OnPlayerConnect ect.",
    "langs": "csharp cs"
  },
  "cs/articles/custom-events.html": {
    "type": "article",
    "href": "cs/articles/custom-events.html",
    "title": "Custom events",
    "keywords": "Improve this Doc Custom events Custom events are automatically validating the arguments the client send via a client event. Everything that is possible with custom events can also be created via Alt.OnPlayerEvent . Custom events are registered via Alt.On(eventName, delegate) . The delegate can have any signature and the module checks when a event occurs if the signature of the delegate fits the event arguments the client sends. For custom events you can't use the lambda operator because it needs to know the parameter types. Here is a very basic sample that expects just a single string from a client event named myMessage . We register it via Alt.On . We need to help the compiler a bit by defining the method parameter types for the generic method. The types are defined from left ro right same as in the method definition itself. Alt.On<IPlayer, string>(\"myMessage\", MyMessageHandler); And the method is defined as this. public void MyMessageHandler(IPlayer player, string message) { } The method will be called like this from client alt.emitServer(\"myMessage\", \"my test message\"). The method name doesn't really matter in this case and i just named it similar to the event name. Supported parameter types are object , bool , int , long , uint , ulong , float , double , string , IPlayer (or any types extending IPlayer), IVehicle (or any types extending IVehicle), Dictionary<string, (any type listed here) , Alt.Function , any type listed here as array e.g. int[]. Also any dictionary in dictionary, array in array, ect. endless depth types are supported, because they are resolved recursively. Dictionaries Any js object send via alt.emitServer will be a dictionary. Alt.On<IPlayer, string>(\"myBigObject\", MyBigObjectHandler); ... public void MyBigObjectHandler(IPlayer player, Dictionary<string, string> myBigObject) { if(!myBigObject.TryGetValue(\"eyeColor\", out var eyeColor)) return; Console.WriteLine($\"EyeColor: {eyeColor}\"); } And this is the client code. const myBigObject = {firstName:\"John\", lastName:\"Doe\", eyeColor:\"blue\"}; alt.emitServer(\"myBigObject\", myBigObject); When you use object as a parameter, or type in dictionary, it will accept any type and you can manually check which type it is.",
    "langs": "csharp cs js"
  },
  "cs/articles/entity-data.html": {
    "type": "article",
    "href": "cs/articles/entity-data.html",
    "title": "Entity data",
    "keywords": "Improve this Doc Entity data Within the C# API, one has different methods to modify data stored on an entity. There are, however, four different data access level that can be used. Data access level The data access level is only accessible within the resource that attached the data. Example For example: Given that the used variable player is the same across different serverside resources, one has this behaviour of the data: // Resource A AltV.Net.Entities.IPlayer player; player.SetData(\"test\", 123); if (player.GetData<int>(\"test\", out var value)) { // value contains 123 } // Resource B AltV.Net.Entities.IPlayer player; if (player.GetData<int>(\"test\", out var value)) { // this scope will not be executed at all / value contains nothing/is the default datatype T (int here) } MetaData access level The meta data access level is accessible by all serverside resources. Example Given are the same conditions as above. // Resource A AltV.Net.Entities.IPlayer player; player.SetMetaData(\"test\", 123); if (player.GetMetaData<int>(\"test\", out var value)) { // value contains 123 } // Resource B AltV.Net.Entities.IPlayer player; if (player.GetMetaData<int>(\"test\", out var value)) { // value contains 123 } Server- and clientside data StreamSyncedMetaData access level The stream synced meta data access level is accessible by all serverside resources and all clients within their streaming range. SyncedMetaData access level Synced meta data can be accessed by the client and server everytime - meaning across all resources and clients without streaming range limitation. Remarks Obviously, the given access levels above are used to reduce network traffic in the one way and to limit the access from other resources. Before you use one of those 4 data access levels, think about what you will need as it might drastically improve your performance. For example, data of a player that is unused by a client, because the target player is out of the streaming range, can be improved by using StreamSyncedData data.",
    "langs": "csharp cs"
  },
  "cs/articles/entity-factories.html": {
    "type": "article",
    "href": "cs/articles/entity-factories.html",
    "title": "Entity factories",
    "keywords": "Improve this Doc Entity factories Entity factories allows you to optimize your server performance by defining the data you need to store in a player or vehicle on compile time. This allows much faster data access than via .SetData, .GetData . Step 1, Create the class Defining your custom player or vehicle class by extending Player or Vehicle . You need to implement the default constructor of Player or Vehicle as well. public class MyPlayer : Player { public bool LoggedIn { get; set; } public MyPlayer(IntPtr nativePointer, ushort id) : base(nativePointer, id) { LoggedIn = false; } } You can't create a player via a constructor, because the player class will be created automatically when someone connects. Thats why you need to create a factory that will create the player for you when its needed. Step 2, Create the factory In the factory the defined default constructor of the player or vehicle class will be called. You only need to override the IPlayer Create(IntPtr playerPointer, ushort id) method and initialize your own class instead of the default one. public class MyPlayerFactory : IEntityFactory<IPlayer> { public IPlayer Create(IntPtr playerPointer, ushort id) { return new MyPlayer(playerPointer, id); } } Step 3, Apply the factory Now you need to tell the module that it should use your own entity factory for the player. You simply do this by overriding IEntityFactory<IPlayer> GetPlayerFactory() method in your Resource class. This will look like the code below. public class SampleResource : Resource { public override IEntityFactory<IPlayer> GetPlayerFactory() { return new MyPlayerFactory(); } } This also works when you extend AsyncResource ect. Vehicle class It works the same for vehicles, but with a small difference, because you can create vehicles via the constructor by defining the vehicle model, position and rotation. Thats why you most likely will add a second constructor to the vehicle that looks like this. public class MyVehicle : Vehicle { public int MyData { get; set; } // This constructor is used for creation via constructor public MyVehicle(uint model, Position position, Rotation rotation) : base(model, position, rotation) { MyData = 7; } // This constructor is used for creation via entity factory public MyVehicle(IntPtr nativePointer, ushort id) : base(nativePointer, id) { MyData = 6; } } Use the custom Entity class For events inside IScript class you can just use your own class instead of IPlayer/IVehicle ect. public class SampleScript: IScript { [ScriptEvent(ScriptEventType.PlayerConnect)] public void MyPlayerConnect(MyPlayer player, string reason) { //... } } For events registered via Alt you can just cast the entities to the custom classes. Alt.OnPlayerConnect += OnPlayerConnect; //... private void OnPlayerConnect(IPlayer player, string reason) { var myPlayer = (MyPlayer)player; //... }",
    "langs": "csharp cs"
  },
  "cs/articles/entity-sync.html": {
    "type": "article",
    "href": "cs/articles/entity-sync.html",
    "title": "Entity Sync",
    "keywords": "Improve this Doc Entity Sync This article will describes how to use the entity sync package to sync custom entities from serverside to clients efficiently. Setup Install the following nuget packages and make sure both packages are on the latest version: https://www.nuget.org/packages/AltV.Net.EntitySync // The core package with the sync logic https://www.nuget.org/packages/AltV.Net.EntitySync.ServerEvent // A optional package that will send the entity sync events to the client via server events Configure the Entity Sync AltEntitySync.Init(1, (threadId) => 100, (threadId) => false, (threadCount, repository) => new ServerEventNetworkLayer(threadCount, repository), (entity, threadCount) => (entity.Id % threadCount), (entityId, entityType, threadCount) => (entityId % threadCount), (threadId) => new LimitedGrid3(50_000, 50_000, 100, 10_000, 10_000, 300), new IdProvider()); Now breakdown the parameters of the Init function: The first parameter is the thread count, this describes the number of thats that will run in parallel to calculate the streamed entities. The second parameter is the sync rate, it describes the interval in which each sync thread calculates the streamed entities and can be configured per thread id. The third parameter is a bool with that you can enable net owner calculations and events. The fourth parameter is the Action that returns a new NetworkLayer for a repository. The ServerEventNetworkLayer is part of the second nuget package. The fifth parameter defines the thread the entity shoud use. The sixth parameter defines the thread a entityId + entityType should use. The seventh parameter is the Action that returns a new space partitioning algorithm for each specific sync thread id. The LimitedGrid3 is one of the algorithms that comes included in the core. LimitedGrid3 has following parameters: (int maxX, int maxY, int areaSize, int xOffset, int yOffset, int limit). The (int maxX, int maxY) parameters are defining the size of the map the grid is inserting, removing and finding entities in. The default values are defining the default gta 5 map. The two offsets (int xOffset, int yOffset) preventing the corrdinates to become negative, because the gta maps goes from -10k to 50k. The (int limit) makes sure a client can only have streamed in the amount of entities he can actually render. E.g. the gta 5 client in altv can only create around 300 Objects without stability issues. The eight and last parameter is the id provider that increments the entity ids incremental and free's unused ids. The IdProvider is included inside the core package as well. Add Entities To add entities that can be streamed there are two ways. The easiert way is to use the CreateEntity method from AltEntitySync. AltEntitySync.CreateEntity(ulong type, Vector3 position, int dimension, uint range, IDictionary<string, object> data); The entity type are your own ids to differentiate between e.g. a object, a ped, a 3d Text, ect. The position is the entity position. The dimension is working same as the dimension of a player, vehicle ect. The range defines the streaming range this entity is streamed in. The data is the data the entity contains when its streamed in on clientside. The second way is to use the entity constructor. var entity = new Entity(ulong type, Vector3 position, int dimension, uint range, IDictionary<string, object> data); AltEntitySync.AddEntity(entity); Remove entities To remove a entity you just need the entity or the entity id. AltEntitySync.RemoveEntity(IEntity entity); // or AltEntitySync.RemoveEntity(ulong id); Update entity position The update the position of a entity just use the position setter. The position is a Vector3. entity.Position = new Vector3(x, y, z); Update entity range The update the range of a entity just use the range setter. The range is a uint and should never be 0. entity.Range = range; Update entity dimension The update the dimension of a entity just use the dimension setter. The dimension is a int. entity.Dimension = dimension; Update entity data The update the range of a entity just use the data methods. Each type that works with Custom Events also works with ServerEventNetworkLayer. entity.SetData(\"my-data\", 123); You can reset the data with. Resetted data is received as null. entity.ResetData(\"my-data\"); Get entity data if (entity.TryGetData(\"my-data\", out int data)) { } Get entity net owner This is always null when third parameter is false, otherwise its the closest player to the entity. entity.NetOwner ServerEventNetworkLayer This describes the events the client receives from the ServerEventNetworkLayer that you need to implement in your client code. Entity create This is called every time you come in the range of the entity. The server assumes you cache the entity depending on the entity.id so make sure to do it. alt.onServer(\"entitySync:create\", (entityId, entityType, position, newEntityData) => { alt.log(entityId); alt.log(entityType); alt.log(position); alt.log(newEntityData); if (newEntityData) { if (!entityData[entityType]) { entityData[entityType] = {}; } if (!entityData[entityType][entityId]) { entityData[entityType][entityId] = {}; } for (const key in newEntityData) { entityData[entityType][entityId][key] = newEntityData[key]; } } let currentEntityData; if (entityData[entityType] && entityData[entityType][entityId]) { currentEntityData = entityData[entityType][entityId]; } else { currentEntityData = null; } alt.log(currentEntityData); }) Entity remove This is called every time you go out of the range of the entity. alt.onServer(\"entitySync:remove\", (entityId, entityType) => { let currentEntityData; if (entityData[entityType]) { currentEntityData = entityData[entityType][entityId]; } else { currentEntityData = null; } alt.log(entityId); alt.log(entityType); alt.log(entityData); }) Entity position update This is called very time you update the entity position while you are in the range of the entity. alt.onServer(\"entitySync:updatePosition\", (entityId, entityType, position) => { let currEntityData; if (entityData[entityType]) { currEntityData = entityData[entityType][entityId]; } else { currEntityData = null; } alt.log(entityId); alt.log(entityType); alt.log(currEntityData); }) Entity data update This is called every time you update the entity data while you are in the range of the entity. alt.onServer(\"entitySync:updateData\", (entityId, entityType, newEntityData) => { if (!entityData[entityType]) { entityData[entityType] = {}; } if (!entityData[entityType][entityId]) { entityData[entityType][entityId] = {}; } if (newEntityData) { for (const key in newEntityData) { entityData[entityType][entityId][key] = newEntityData[key]; } } let currentEntityData = entityData[entityType][entityId]; }) Entity clear cache This is called every time you remove a entity on serverside completely and clients still have data in cache of this entity. alt.onServer(\"entitySync:clearCache\", (entityId, entityType) => { if (!entityData[entityType]) { return; } delete entityData[entityType][entityId]; }) Entity net owner This is called when you set the third parameter to true and the current client becomes the net owner of the entity by beeing the closest player to the entity. alt.onServer(\"entitySync:netOwner\", (entityId, entityType, isNetOwner) => { //... }) Now you can call your own logic inside the events to spawn objects, npcs, 3d text, markers, ... ect.",
    "langs": "csharp cs js"
  },
  "cs/articles/events.html": {
    "type": "article",
    "href": "cs/articles/events.html",
    "title": "Events",
    "keywords": "Improve this Doc Events For custom events see Custom Events . Events can be registered via scripts or dynamically via event delegates. This documentation is registering events via delegates dynamically. To add for example a player connect event handler dynamically you can just add the delegate that will be called when a player connects. This is a example using the lambda operator to add a event handler. Alt.OnPlayerConnect += (player, reason) => { Console.WriteLine($\"{player.Name} connected.\"); }; Its also possible to add a method instead of using a lambda. The method can be private, public, static ect. Alt.OnPlayerConnect += OnPlayerConnect; ... public void OnPlayerConnect(IPlayer player, string reason) { Console.WriteLine($\"{player.Name} connected.\"); } You should not register event handlers in async code. Below is a list of all event handlers. using AltV.Net.Events; namespace AltV.Net { public static partial class Alt { public static event CheckpointDelegate OnCheckpoint { add => Module.CheckpointEventHandler.Add(value); remove => Module.CheckpointEventHandler.Remove(value); } /// <summary> /// Player connect event handler /// <example> /// <code> /// Alt.OnPlayerConnect += (player, reason) => { /// Console.WriteLine($\"{player.Name} connected.\"); /// }; /// </code> /// </example> /// </summary> public static event PlayerConnectDelegate OnPlayerConnect { add => Module.PlayerConnectEventHandler.Add(value); remove => Module.PlayerConnectEventHandler.Remove(value); } public static event ResourceEventDelegate OnAnyResourceStart { add => Module.ResourceStartEventHandler.Add(value); remove => Module.ResourceStartEventHandler.Remove(value); } public static event ResourceEventDelegate OnAnyResourceStop { add => Module.ResourceStopEventHandler.Add(value); remove => Module.ResourceStopEventHandler.Remove(value); } public static event ResourceEventDelegate OnAnyResourceError { add => Module.ResourceErrorEventHandler.Add(value); remove => Module.ResourceErrorEventHandler.Remove(value); } public static event PlayerDamageDelegate OnPlayerDamage { add => Module.PlayerDamageEventHandler.Add(value); remove => Module.PlayerDamageEventHandler.Remove(value); } public static event PlayerDeadDelegate OnPlayerDead { add => Module.PlayerDeadEventHandler.Add(value); remove => Module.PlayerDeadEventHandler.Remove(value); } public static event ExplosionDelegate OnExplosion { add => Module.ExplosionEventHandler.Add(value); remove => Module.ExplosionEventHandler.Remove(value); } /// <summary> /// Weapon damage event handler /// <example> /// <code> /// Alt.OnWeaponDamage += (player, target, weapon, damage, shotOffset, bodyPart) => { /// Console.WriteLine($\"{player.Name} got damaged.\"); /// return true; // return false will cancel the weapon damage event and player won't receive damage. /// }; /// </code> /// </example> /// </summary> public static event WeaponDamageDelegate OnWeaponDamage { add => Module.WeaponDamageEventHandler.Add(value); remove => Module.WeaponDamageEventHandler.Remove(value); } public static event PlayerDisconnectDelegate OnPlayerDisconnect { add => Module.PlayerDisconnectEventHandler.Add(value); remove => Module.PlayerDisconnectEventHandler.Remove(value); } public static event PlayerRemoveDelegate OnPlayerRemove { add => Module.PlayerRemoveEventHandler.Add(value); remove => Module.PlayerRemoveEventHandler.Remove(value); } public static event VehicleRemoveDelegate OnVehicleRemove { add => Module.VehicleRemoveEventHandler.Add(value); remove => Module.VehicleRemoveEventHandler.Remove(value); } public static event PlayerChangeVehicleSeatDelegate OnPlayerChangeVehicleSeat { add => Module.PlayerChangeVehicleSeatEventHandler.Add(value); remove => Module.PlayerChangeVehicleSeatEventHandler.Remove(value); } public static event PlayerEnterVehicleDelegate OnPlayerEnterVehicle { add => Module.PlayerEnterVehicleEventHandler.Add(value); remove => Module.PlayerEnterVehicleEventHandler.Remove(value); } public static event PlayerEnteringVehicleDelegate OnPlayerEnteringVehicle { add => Module.PlayerEnteringVehicleEventHandler.Add(value); remove => Module.PlayerEnteringVehicleEventHandler.Remove(value); } public static event PlayerLeaveVehicleDelegate OnPlayerLeaveVehicle { add => Module.PlayerLeaveVehicleEventHandler.Add(value); remove => Module.PlayerLeaveVehicleEventHandler.Remove(value); } public static event PlayerClientEventDelegate OnPlayerEvent { add => Module.PlayerClientEventEventHandler.Add(value); remove => Module.PlayerClientEventEventHandler.Remove(value); } public static event PlayerClientCustomEventDelegate OnPlayerCustomEvent { add => Module.PlayerClientCustomEventEventHandler.Add(value); remove => Module.PlayerClientCustomEventEventHandler.Remove(value); } public static event ServerEventEventDelegate OnServerEvent { add => Module.ServerEventEventHandler.Add(value); remove => Module.ServerEventEventHandler.Remove(value); } public static event ServerCustomEventEventDelegate OnServerCustomEvent { add => Module.ServerCustomEventEventHandler.Add(value); remove => Module.ServerCustomEventEventHandler.Remove(value); } public static event ConsoleCommandDelegate OnConsoleCommand { add => Module.ConsoleCommandEventHandler.Add(value); remove => Module.ConsoleCommandEventHandler.Remove(value); } /// <summary> /// Event that is invoked when the meta data of an entity has changed. /// </summary> /// <remarks>Meta data is accessible across different serverside resources.</remarks> public static event MetaDataChangeDelegate OnMetaDataChange { add => Module.MetaDataChangeEventHandler.Add(value); remove => Module.MetaDataChangeEventHandler.Remove(value); } /// <summary> /// Event that is invoked when the synced meta data of an entity has changed. /// </summary> /// <remarks>Synced meta data is accessible across different serverside resources and to all clients without range limitation.</remarks> public static event MetaDataChangeDelegate OnSyncedMetaDataChange { add => Module.SyncedMetaDataChangeEventHandler.Add(value); remove => Module.SyncedMetaDataChangeEventHandler.Remove(value); } public static event ColShapeDelegate OnColShape { add => Module.ColShapeEventHandler.Add(value); remove => Module.ColShapeEventHandler.Remove(value); } public static event VehicleDestroyDelegate OnVehicleDestroy { add => Module.VehicleDestroyEventHandler.Add(value); remove => Module.VehicleDestroyEventHandler.Remove(value); } public static event FireDelegate OnFire { add => Module.FireEventHandler.Add(value); remove => Module.FireEventHandler.Remove(value); } public static event StartProjectileDelegate OnStartProjectile { add => Module.StartProjectileEventHandler.Add(value); remove => Module.StartProjectileEventHandler.Remove(value); } public static event PlayerWeaponChangeDelegate OnPlayerWeaponChange { add => Module.PlayerWeaponChangeEventHandler.Add(value); remove => Module.PlayerWeaponChangeEventHandler.Remove(value); } public static event NetOwnerChangeDelegate OnNetworkOwnerChange { add => Module.NetOwnerChangeEventHandler.Add(value); remove => Module.NetOwnerChangeEventHandler.Remove(value); } public static event VehicleAttachDelegate OnVehicleAttach { add => Module.VehicleAttachEventHandler.Add(value); remove => Module.VehicleAttachEventHandler.Remove(value); } public static event VehicleDetachDelegate OnVehicleDetach { add => Module.VehicleDetachEventHandler.Add(value); remove => Module.VehicleDetachEventHandler.Remove(value); } } } Below is a list of all event handler method signatures. using AltV.Net.Data; using AltV.Net.Elements.Args; using AltV.Net.Elements.Entities; using AltV.Net.Native; namespace AltV.Net.Events { public delegate void CheckpointDelegate(ICheckpoint checkpoint, IEntity entity, bool state); public delegate void ClientEventDelegate(IPlayer player, object[] args); public delegate void PlayerConnectDelegate(IPlayer player, string reason); public delegate void ResourceEventDelegate(INativeResource resource); public delegate void PlayerDamageDelegate(IPlayer player, IEntity attacker, uint weapon, ushort damage); public delegate void PlayerDeadDelegate(IPlayer player, IEntity killer, uint weapon); public delegate void PlayerDisconnectDelegate(IPlayer player, string reason); public delegate void PlayerRemoveDelegate(IPlayer player); public delegate void VehicleRemoveDelegate(IVehicle vehicle); public delegate void ServerEventDelegate(object[] args); public delegate void PlayerClientEventDelegate(IPlayer player, string eventName, object[] args); public delegate void PlayerClientCustomEventDelegate(IPlayer player, string eventName, MValueConst[] mValueArray); public delegate void PlayerChangeVehicleSeatDelegate(IVehicle vehicle, IPlayer player, byte oldSeat, byte newSeat); public delegate void PlayerEnterVehicleDelegate(IVehicle vehicle, IPlayer player, byte seat); public delegate void PlayerEnteringVehicleDelegate(IVehicle vehicle, IPlayer player, byte seat); public delegate void PlayerLeaveVehicleDelegate(IVehicle vehicle, IPlayer player, byte seat); public delegate void ServerEventEventDelegate(string eventName, object[] args); public delegate void ServerCustomEventEventDelegate(string eventName, MValueConst[] mValueArray); public delegate void ConsoleCommandDelegate(string name, string[] args); public delegate void MetaDataChangeDelegate(IEntity entity, string key, object value); public delegate void ColShapeDelegate(IColShape colShape, IEntity targetEntity, bool state); public delegate bool ExplosionDelegate(IPlayer player, ExplosionType explosionType, Position position, uint explosionFx, IEntity targetEntity); public delegate bool WeaponDamageDelegate(IPlayer player, IEntity target, uint weapon, ushort damage, Position shotOffset, BodyPart bodyPart); public delegate void VehicleDestroyDelegate(IVehicle vehicle); public delegate bool FireDelegate(IPlayer player, FireInfo[] fireInfos); public delegate bool StartProjectileDelegate(IPlayer player, Position startPosition, Position direction, uint ammoHash, uint weaponHash); public delegate bool PlayerWeaponChangeDelegate(IPlayer player, uint oldWeapon, uint newWeapon); public delegate void NetOwnerChangeDelegate(IEntity target, IPlayer oldNetOwner, IPlayer newNetOwner); public delegate void VehicleAttachDelegate(IVehicle target, IVehicle attachedVehicle); public delegate void VehicleDetachDelegate(IVehicle target, IVehicle detachedVehicle); } The player event handler looks like this. Alt.OnPlayerEvent += (player, name, args) => { }; For automated arguments validating you can use Custom Events .",
    "langs": "csharp cs"
  },
  "cs/articles/index.html": {
    "type": "article",
    "href": "cs/articles/index.html",
    "title": "Getting Started",
    "keywords": "Improve this Doc Getting Started This is the documentation for getting started developing c# resources. Read Setup for setting up the basics and getting ready for work. Read Create Resource for creating a c# resource. Read Create Script to learn the first steps about how to write code for your own resource. Read Events for an introduction about handling alt:V standard events. Read Custom Events to understand how custom events are emitted and handled. Read Entity factories to get an understanding about how to handle meta-like data more efficient. Read Checkpoints to learn about checkpoints.",
    "langs": ""
  },
  "cs/articles/interactions.html": {
    "type": "article",
    "href": "cs/articles/interactions.html",
    "title": "Interactions",
    "keywords": "Improve this Doc Interactions This article will describe how to add fast serverside player interactions. You can also use the interactions for something else then player interactions, but player interactions are the common usecase for them. Setup Interactions First download the nuget package to access the interaction api's: https://www.nuget.org/packages/AltV.Net.interactions Next you need to init the interactions package. The best place to do this is when your resource is starting. Note: It doesn't matter if your resource is a async resource. The code below is just for illustrating how to do it in general. public class MyResource: Resource { public override void OnStart() { // (some code from you) AltInteractions.Init(); // (some code from you) } public override void OnStop() { // (some code from you) AltInteractions.Dispose(); // (some code from you) } } Now the interaction package setup is done and ready to be used. Create interactions To create a interaction you need to create a instance of it first. This is how the default constructor looks like. var interaction = new Interaction(ulong type, ulong id, Vector3 position, int dimension, uint range); The first parameter is the type. This defines the interaction type. A type can be anything you want to use it for. A example might be: type 1 = house, type 2 = car shop, ect. The second parameter is the id. This defines the interaction id for the given type. Only the id + type in combination needs to be unique. You can have the same id used in different types. This is useful when you already have ids for houses and car shops and both have own auto incrementing counters starting at 1. The third parameter is the position. This defines the position this interaction is present. The fourth parameter is the dimension. This defines the dimension this interaction is visible inside. The dimension logic is the same as for players, vehicle ect. X can see only X -X can see 0 and -X 0 can't see -X and X And the fifth and last parameter is the range. This defines the range this interaction is usable in. Add Interactions To add a interaction to the system you can just call: AltInteractions.AddInteraction(interaction); Remove Interactions To remove a interaction from the system you can just call: AltInteractions.RemoveInteraction(interaction); Find Interactions To find all interactions that are on a specific position and visible for a specific dimensions you can call: var interactions = await AltInteractions.FindInteractions(position, dimension); As you can see on the code this method returns a task that needs to be awaited. Now we have a list of all interactions that are visible at this specific dimension and are in range of the positions. The returned object is null when no interactions are found. foreach (var interaction in interactions) { // do stuff with interaction.Id and interaction.Type } Create custom interactions You might want to add custom interactions to add custom data to them. One example would be to add your house object to the interaction. You have to add the default constructor when inherit from Interaction public class HouseInteraction: Interaction { public HouseEntity House { get; } public HouseInteraction( HouseEntity house, ulong type, ulong id, Vector3 position, int dimension, uint range) : base(type, id, position, dimension, range) { House = house; } } Lets see how our interactions loop from above now looks like: foreach (var interaction in interactions) { if (interaction is HouseInteraction houseInteraction) { // do something with houseInteraction.House } } We can now get the house object from the interaction instead of using the interaction id and type to fetch it. Note: You still should use the correct id and type to add and remove the interactions correctly. Trigger interactions With custom classes you can make use of another feature that is available. The Interaction class has a abstract method you can override. public class HouseInteraction: Interaction { public HouseEntity House { get; } public HouseInteraction( HouseEntity house, ulong type, ulong id, Vector3 position, int dimension, uint range) : base(type, id, position, dimension, range) { House = house; } public override bool OnInteraction(IPlayer player, Vector3 interactionPosition, int interactionDimension) { // do something with the House obj return false; } } This method is getting triggered each time you call: AltInteractions.TriggerInteractions(player); When you returns false from a interaction you allow other interactions that might be in range as well to also call OnInteraction. When you return true, no other interaction will trigger. The OnInteraction method is triggered inside a async context. It should be none blocking to not block other interactions since they run in the same task. When you need to use await inside it start a new task with Task.Run. Make sure to use the altv.net apis inside the async context correctly.",
    "langs": "csharp cs"
  },
  "cs/articles/internal_information.html": {
    "type": "article",
    "href": "cs/articles/internal_information.html",
    "title": "Internal information",
    "keywords": "Improve this Doc Internal information This section provides a high-level overview about the internal structure of the C# module and how it's playing together with the AltV server. Important Resource developers don't need to know the internal structure, but it is helpful sometimes. This is mainly for developers who like to contribute to the C# module. Initialization of csharp-module When the altv-server is starting it checks modules part of the server.cfg configuration file. When there's the csharp-module specified, the server loads the \"csharp-module.dll\" / \"libcsharp-module.so\" / \"csharp-module.so\" (depending on operating system) from the modules folder. In the csharp-module is a function altMain defined, which starts the .NET runtime and registers itself as script runtime for csharp resources. That's the reason you have to specify type: csharp in the resource.cfg , so the altv-server knows that it should load this resource with the csharp-module. The custom .NET host tries to find the latest .NET SDK hostfxr.dll (example path on Windows is C:\\Program Files (x86)\\dotnet\\host\\fxr\\5.0.1\\hostfxr.dll ). When it's found, it starts AltV.Net.Host.dll which is located next to the altv-server . Now in .NET world the AltV.Net.Host first initialize some delegates which can be triggered from the csharp-module . For example the csharp-module can trigger a delegate to start a specific resource with a name, path and a main file. The main initialization is now done and we are waiting until a resource of type csharp should be loaded. Summary: altv-server calls platform dependent csharp-module csharp-module acts as custom .NET host, starts .NET runtime with AltV.Net.Host.dll AltV.Net.Host initializes delegates which can be executed from csharp-module Loading a resource For every C# resource the csharp-module creates a CSharpResourceImpl . When the resource is started by the server, the class triggers AltV.Net.Host with the previous initialized ExecuteResource delegate. There a custom AssemblyLoadContext is created, which is responsible for loading and resolving assemblies like the resource and their dependencies. The load context loads the files just from the resource folder which it is created for and is isolated from other resources. In the end the resource assembly is loaded and the AltV.Net.dll assembly is initialized by calling the ModuleWrapper#MainWithAssembly among others. Here the main initialization happens: The entity factories are resolved which are needed for creating the entity pools. These entity pools are storing the active entities like for example currently connected players in the player pool. In order to receive events later from the server, it's required to set delegates which are executed on the csharp-module . This is done in CSharpResourceImpl from AltV.Net assembly. The functions which are executed are in ModuleWrapper and there the module functions are triggered. Depending if the resource derives from Resource or AsyncResource a different module is resolved. The AsyncModule is thereby derived from Module . The module is the main class which stores all entity pools, forwards events to IScript methods and the event handlers in resources, like Alt.OnPlayerEnterVehicle and so on. Afterwards the load context will be searched for implementations of IScript . These classes can have methods with custom attributes like ScriptEventAttribute . When specified for example ScriptEventType.PlayerConnect this method will be called every time a player connects. In order to get that working every IScript is loaded and the events registered. There are simply the Alt.On* events used (for non-async attributes). For PlayerConnect , there is an event handler for Alt.OnPlayerConnect which triggers the IScript method. Last but not least the csharp-module is now triggering the MainDelegate which is received in the ModuleWrapper . There it just execute the OnStart method of the resource. This OnStart has every resource implemented, as it is a abstract method on the Resource class. Summary: altv-server calls csharp-module to start resource csharp-module creates CSharpResourceImpl which triggers AltV.Net.Host AltV.Net.Host loads resource assembly and dependencies (with AltV.Net ) AltV.Net initializes itself and resource csharp-module triggers MainDelegate which executes resource OnStart Executing commands When executing a command like Alt.CreateVehicle the static Alt class is just a proxy for internal methods. In the end it will trigger most likely a method inside of AltNative . This is a partial class (multiple files which are combined to one class) and acts as thin wrapper for the csharp-module . In the vehicle example AltNative.Server_CreateVehicle is executed, which is a exported function in the csharp-module . The Alt.Net assembly uses the DllImportAttribute to call the method from the native library. Inside of the csharp-module the data is copied to internal data structures and then send to the altv-server . Receiving events The events are received in the csharp-module . Every resource receives most of the events in CSharpResourceImpl::OnEvent . This prepares the data and executes a method of the ModuleWrapper with a delegate previous set in the initialization. For example for the alt::CEvent::Type::PLAYER_ENTER_VEHICLE the required data is retrieved from the event and OnPlayerEnterVehicleDelegate is executed. This delegate is part of ModuleWrapper and there directly the OnPlayerEnterVehicle method of the loaded module is executed. From there the entites are checked if these are valid and exists on the server. In the end all registered event handler are executed, like Alt.OnPlayerEnterVehicle or ScriptEventAttribute .",
    "langs": ""
  },
  "cs/articles/loop-all.html": {
    "type": "article",
    "href": "cs/articles/loop-all.html",
    "title": "Loop all fast and secure",
    "keywords": "Improve this Doc Loop all fast and secure This article will describe how to loop players, vehicles, ect. fast and secure. You first have to create a custom class that implements the callback interface. There are two callback interfaces to implement. IBaseObjectCallback is used for none async code. The loop execution also blocks the execution on the main thread. You should also not use async code within the callback (or at least lock usage of entities). IAsyncBaseObjectCallback which is for calling async code in it. The callback gets executed inside of an own task and therefore is awaitable. Use this callback class either when you have to execute asynchronous code inside the loop or when the loop call itself gets executed asynchronously (not in main thread). The entity object parameter by using this callback class is validated and it is safe to be used outside of the main thread without need of using lock statements. Remember that you have to inherit your resource class from AsyncResource (AltAsync package) instead of Resource , otherwise you don't have entity validation. Technically both callbacks, no mather the interface can be called in async code. IAsyncBaseObjectCallback will result in returning a Task and uses async safe entity references (like AsyncPlayerRef instead of PlayerRef when iterating over players). This example is for IPlayer's but can be used for IVehicle , IBlip , ICheckpoint , IColShape and IVoiceChannel as well. class MyPlayerCallback : IBaseObjectCallback<IPlayer> { public void OnBaseObject(IPlayer player) { // do something CheckPlayerPosition(player.Position); } } class MyPlayerSaveToDBCallback : IAsyncBaseObjectCallback<IPlayer> { public async Task OnBaseObject(IPlayer player) { // do something var dbPlayer = await LoadPlayerFromDb(player.Id); await SavePlayer(dbPlayer); } } Now you can create some class instances. var myPlayerCallback = new MyPlayerCallback(); var myPlayerSaveToDBCallback = new MyPlayerSaveToDbCallback(); Now you can trigger the OnBaseObject calls inside them. await Alt.ForEachPlayers(myPlayerSaveToDBCallback); Alt.ForEachPlayers(myPlayerCallback); As you can see the ForEachPlayers method returns a Task that is done when all OnBaseObject calls that return a Task are done as well. They are currently called sequently. Its allowed to reuse the created class instances for as many calls as you want. Exceptions inside a callback will result into the method to fail and forward the exception to the caller. Function / lambda callbacks Since writing multiple classes for each iteration purpose can be exhausting, you can also use these two generic callback implementations. With them you can use lambda expressions to define the loop code. Just keep in mind that using classes is better in performance than using lambda functions (which is probably negligible). public class FunctionCallback<T> : IBaseObjectCallback<T> where T : IBaseObject { private readonly Action<T> _callback; public FunctionCallback(Action<T> callback) { _callback = callback; } public void OnBaseObject(T baseObject) { _callback(baseObject); } } public class AsyncFunctionCallback<T> : IAsyncBaseObjectCallback<T> where T : IBaseObject { private readonly Func<T, Task> _callback; public AsyncFunctionCallback(Func<T, Task> callback) { _callback = callback; } public Task OnBaseObject(T baseObject) { return _callback(baseObject); } } Usage: var callback = new FunctionCallback<IPlayer>(player => { // do something CheckPlayerPosition(player.Position); }); Alt.ForEachPlayers(callback); var asyncCallback = new AsyncFunctionCallback<IPlayer>(async (player) => { // do something var dbPlayer = await LoadPlayerFromDb(player.Id); await SavePlayer(dbPlayer); }); Alt.ForEachPlayers(asyncCallback); If you need entity validation without having the need for using await statement you can do this: var asyncCallback = new AsyncFunctionCallback<IPlayer>(async (player) => { // do something Alt.Log(player.Name); await Task.CompletedTask; // you need at least one await statement in async methods }); Alt.ForEachPlayers(asyncCallback);",
    "langs": "csharp cs"
  },
  "cs/articles/player_connect.html": {
    "type": "article",
    "href": "cs/articles/player_connect.html",
    "title": "Player connect event",
    "keywords": "Improve this Doc Player connect event This is called when a player connects. Parameter Description player The player that connected reason The reason with that the player connected Normal event handler Alt.OnPlayerConnect += (player, reason) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript Class! Otherwise it won´t work! // We create our IScript class public class MyIScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerConnect)] public void OnPlayerConnect(IPlayer player, string reason) { // We loop through every player on our server and notify them foreach(IPlayer players in Alt.GetAllPlayers()) { // We notify everyone that our Client has joined the Server players.SendChatMessage(player.Name + \" has joined the Server.\"); } // We spawn the newly connected player player.Spawn(new Position(0, 0, 72)); // We set his skin to the standard gta online freemode skin player.Model = Alt.Hash(\"FreemodeMale01\"); } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_damage.html": {
    "type": "article",
    "href": "cs/articles/player_damage.html",
    "title": "PlayerDamage",
    "keywords": "Improve this Doc PlayerDamage This is called everytime a player receives damage. Parameter Description player The player that received damage. entity The entity who gave damage to the player. weapon The weapon that was used or a other reason https://github.com/FabianTerhorst/coreclr-module/blob/master/api/AltV.Net/Data/Weapons.cs damage The damage that the player received. Normal event handler Alt.OnPlayerDamage += (player, attacker, weapon, damage) => { // ... }; IScript event handler This event will be called if a player receive any kind of damage. Note : ScriptEvents have to be created in a IScript Class! Otherwise they won't get called. // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerDamage)] public static void PlayerDamage(IPlayer player, IEntity attacker, uint weapon, ushort damage) { // We create a switch-statement where we check the type of our IEntity. switch (attacker) { case IPlayer sender: player.SendChatMessage(\"You received damage by \" + sender.Name + \".\"); player.SendChatMessage(\"His weapon was a \" + (WeaponModel)weapon + \".\"); return; case IVehicle sender: player.SendChatMessage(\"You received damage by a \" + (VehicleModel)sender.Model); return; default: player.SendChatMessage(\"You received damage.\"); return; } } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_death.html": {
    "type": "article",
    "href": "cs/articles/player_death.html",
    "title": "Player dead event",
    "keywords": "Improve this Doc Player dead event This is called when a player dies. Parameter Description player The player that got killed killer The killer who killed the player weapon The weapon that was used or a other reason https://github.com/FabianTerhorst/coreclr-module/blob/master/api/AltV.Net/Data/Weapons.cs Normal event handler Alt.OnPlayerDead += (player, killer, weapon) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript class! Otherwise it won't work! // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerDead)] public static void OnPlayerDead(IPlayer player, IEntity attacker, uint weapon) { string deathReason = attacker switch { IPlayer attackerPlayer when attackerPlayer == player => \"yourself!\", IPlayer killerPlayer => killerPlayer?.Name, IVehicle vehicle => \"a \" + ((VehicleModel)vehicle?.Model), _ => \"world caused damage.\" }; player?.SendChatMessage(\"You got killed by \" + deathReason); player?.Spawn(new Vector3(0, 0, 72), 1000); // <= We spawn the dead player after 1000ms. } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_disconnect.html": {
    "type": "article",
    "href": "cs/articles/player_disconnect.html",
    "title": "Player disconnect event",
    "keywords": "Improve this Doc Player disconnect event This is called when a player disconnects. Parameter Description player The player that disconnected reason The reason with that the player disconnected Normal event handler Alt.OnPlayerDisconnect += (player, reason) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript Class! Otherwise it won´t work! // We create our IScript class public class MyIScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerDisconnect)] public void OnPlayerDisconnect(IPlayer player, string reason) { // We loop through every player on our server and notify them foreach(IPlayer players in Alt.GetAllPlayers()) { // We notify everyone that our Client has joined the Server players.SendChatMessage(player.Name + \" has left the Server.\"); } } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_enter_vehicle.html": {
    "type": "article",
    "href": "cs/articles/player_enter_vehicle.html",
    "title": "Player enter vehicle event",
    "keywords": "Improve this Doc Player enter vehicle event This is called when a player enters a vehicle. Parameter Description vehicle The vehicle that the player entered player The player who is entering a vehicle seat The seat where the player entered Normal event handler Alt.OnPlayerEnterVehicle += (vehicle, player, seat) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript Class! Otherwise it won´t work! // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerEnterVehicle)] public static void OnPlayerEnterVehicle(IVehicle vehicle, IPlayer player, byte seat) { // Simple output. player?.SendChatMessage(\"Damn \" + player.Name + \"... you've entered a \" + (VehicleModel)vehicle?.Model); } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_events.html": {
    "type": "article",
    "href": "cs/articles/player_events.html",
    "title": "Player Events",
    "keywords": "Improve this Doc Player Events This section contains a list of articles about the player events. Death Weapon damage Connect Disconnect Weapon change",
    "langs": ""
  },
  "cs/articles/player_giveweapon.html": {
    "type": "article",
    "href": "cs/articles/player_giveweapon.html",
    "title": "GiveWeapon",
    "keywords": "Improve this Doc GiveWeapon Gives a player a Weapon. Note : Event handler have to be Created in a IScript Class! Otherwise it won´t work. /* We create our IScript class */ public class AltV_Wiki : IScript { /* We declare & Create our Event Handler. */ [ScriptEvent(ScriptEventType.PlayerConnect)] public void OnPlayerConnect(IPlayer player, string reason) { //We spawn our Connected Client after 1 sec. client.Spawn(new Position(0, 0, 72)); // We set his Skin to the standard GTA Online Skin. client.Model = Alt.Hash(\"FreemodeMale01\"); // We give our Connected Player a Advanced Rifle with 90 Bullets! He should select his new Weapon Instantly. player.GiveWeapon(AltV.Net.Enums.WeaponModel.AdvancedRifle, 90, true); } } Syntax //Parameter : (WeaponModel weaponModel, int ammo, bool selectWeapon) player.GiveWeapon(AltV.Net.Enums.WeaponModel.AdvancedRifle, 90, true);",
    "langs": "csharp cs"
  },
  "cs/articles/player_leave_vehicle.html": {
    "type": "article",
    "href": "cs/articles/player_leave_vehicle.html",
    "title": "Player leave vehicle event",
    "keywords": "Improve this Doc Player leave vehicle event This is called when a player leaves a vehicle. Parameter Description vehicle The vehicle that the player left player The player who is leaving his current vehicle seat The seat where the player left Normal event handler Alt.OnPlayerLeaveVehicle += (vehicle, player, seat) => { // ... } IScript event handler Note : ScriptEvents have to be created in a IScript Class! Otherwise it won´t work! // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.PlayerLeaveVehicle)] public static void OnPlayerLeaveVehicle(IVehicle vehicle, IPlayer player, byte seat) { // Simple output. player?.SendChatMessage(\"Damn \" + player.Name + \"... you've left your awesome \" + (VehicleModel)vehicle?.Model); } }",
    "langs": "csharp cs"
  },
  "cs/articles/player_weapon_change.html": {
    "type": "article",
    "href": "cs/articles/player_weapon_change.html",
    "title": "PlayerWeaponChange",
    "keywords": "Improve this Doc PlayerWeaponChange The player weapon change event gets called when the player weapon changed. Parameter Description player The player that got his weapons changed oldweapon The weapon that was used https://github.com/FabianTerhorst/coreclr-module/blob/master/api/AltV.Net/Enums/WeaponModel.cs newWeapon The weapon that was used https://github.com/FabianTerhorst/coreclr-module/blob/master/api/AltV.Net/Enums/WeaponModel.cs Normal event handler Alt.OnPlayerWeaponChange += (player, oldWeapon, newWeapon) => { return true; // return false if you wanna cancel it. } IScript event handler // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler. [ScriptEvent(ScriptEventType.PlayerWeaponChange)] public bool OnPlayerWeaponChange(IPlayer player, uint oldWeapon, uint newWeapon) { // We notify the player that he changed his weapon. player.SendChatMessage(\"You changed your Weapon from \" + (WeaponModel)oldWeapon + \" to \" + (WeaponModel)newWeapon); return true; // return false if you wanna cancel it. } }",
    "langs": "csharp cs"
  },
  "cs/articles/player-communication.html": {
    "type": "article",
    "href": "cs/articles/player-communication.html",
    "title": "Player communication",
    "keywords": "Improve this Doc Player communication On serverside two ways exists to send data to clients. The first way is to use Alt.EmitAllClients(eventName, args) to send data to all connected clients. The second way sends data to a specific player directly via player.Emit(eventName, args) . args expects a object[] . Supported arguments types inside the array are byte[] , object , bool , int , long , uint , ulong , float , double , string , IPlayer (or any types extending IPlayer), IVehicle (or any types extending IVehicle), Vector3 , Rotation , Position , IBlip (or any types extending IBlip), IVoiceChannel (or any types extending IVoiceChannel), IColShape (or any types extending IColShape), ICheckpoint (or any types extending ICheckpoint) Dictionary<string, (any type listed here) , Alt.Function , any type listed here as array e.g. int[]. Also any dictionary in dictionary, array in array, ect. endless depth types are supported, because they are resolved recursively. Clientside To catch the event inside clientside javascript. import * as alt from \"alt\"; alt.onServer(eventName, (args) => { }); // or alt.onServer(eventName, (arg1, arg2) => { }); // ect. To send events to server from clientside javascript. import * as alt from \"alt\"; alt.emitServer(eventName, args);",
    "langs": "js"
  },
  "cs/articles/resource-communication.html": {
    "type": "article",
    "href": "cs/articles/resource-communication.html",
    "title": "Resource communication",
    "keywords": "Improve this Doc Resource communication This article will describe how to communicate between different server resources. Export data Resources can define data that other resources can access while the resource is starting. This data is immutable after resource finished starting and can be accessed from any serverside resource. public class SampleResource : AsyncResource { public override void OnStart() { var value = \"test\"; Alt.Export(\"myDataKey\", value); } } You can export any data you can also send via events. Including: object , bool , int , long , uint , ulong , float , double , string , IPlayer (or any types extending IPlayer), IVehicle (or any types extending IVehicle), Dictionary<string, (any type listed here) , Alt.Function , any type listed here as array e.g. int[]. Also any dictionary in dictionary, array in array, ect. endless depth types are supported, because they are resolved recursively. Export functions Functions are also possible to export. Supported function parameters are same types supported by events and exports. public class SampleResource : AsyncResource { public override void OnStart() { Alt.Export(\"myFunction\", new Action<int>(Myfunc)); Alt.Export(\"myFunction2\", new Func<int, bool>(Myfunc2)); } public void Myfunc(int myInt) { } public bool Myfunc2(int myInt) { } } Import data Resources can import data that got exported from other resources. Most likely you will define the resource where you import from as deps: [ myResource, myResource2 ] in your resource.cfg to make sure the resource is already started when your resource starts. You also have to define the resource name where you import data from. public class SampleResource : AsyncResource { public override void OnStart() { Alt.Import(\"myResourceToImportFrom\", \"myFunction\", out Action<int> myFunction); myFunction(13); } } This works the same with functions that return data. The return type is always the last generic type in Func<...> . public class SampleResource : AsyncResource { public override void OnStart() { Alt.Import(\"myResourceToImportFrom\", \"myFunction2\", out Func<int, bool> myFunction); Console.WriteLine(myFunction(13)); } } Events Another way to communicate with resources is by sending events to them. The Alt.Emit(\"eventName\", values) works same as player events and supports all data types that are supported by exports. Every resource will get notified about the event. You can listen explicit for server events via Alt.OnServer(\"eventName\", OnServerEvent) . The server event delegate needs to have to following signature. public void OnServerEvent(object[] args) { }",
    "langs": "csharp cs"
  },
  "cs/articles/resource-initialization-order.html": {
    "type": "article",
    "href": "cs/articles/resource-initialization-order.html",
    "title": "Resource initialization order",
    "keywords": "Improve this Doc Resource initialization order Why you should know the initialization order The Resource and AsyncResource classes provide overridable methods to modify the instantiation of players or vehicles and to modify the pools of those entities - just to name some. Now, one could need custom parameters while instantiating, for example, a new class inheriting from IPlayer , assuming that there exists a player factory ( MyPlayerFactory ) using a custom argument ( myConstant ) in the constructor, which is later on passed to the player class. public override IEntityFactory<IPlayer> GetPlayerFactory() { return new MyPlayerFactory(/* insert your value for myConstant */); } This could be an example, where a constructor argument is needed. Now, consider the case where your player - and thus your player factory - needs a constructor value which is also used by other components later on in the initialization process. Then you probably would like to know which initialization order the alt:V follows, to provide the correct instances and values to all of your components. For example, for the example above, you would have to create the value in the constructor and save it to a class variable like this: class MyResource : Resource { private string mySecret; public MyResource() { mySecret = \"1234\"; } public override IEntityFactory<IPlayer> GetPlayerFactory() { return new MyPlayerFactory(mySecret); } public override OnStart() { // we could need our secret also here new AnotherComponent(mySecret); } public override OnStop() {} } Initialization order The initialization order is as follows: 1. Resource constructor A resource in C# is created by either inheriting from Resource or AsyncResource on a class and provide overrides for OnStart() and OnStop() . The constructor of the class inheriting from Resource or AsyncResource is called first, which makes sense because the class of the resource has to be instantiated. 2. Entity factories and entity pool methods Second, the entity factory and entity pool methods are called, since before the resource starts, the internal module (of type Module ) has to know about all factories and pools as they can not be changed later on. 3. GetModule override After the creation of entity factories and entity pools, GetModule is called with all its arguments. 4. OnStart override Nothing much to say about it. The literal start of the resource is about to be begin. 5. Intermediate overrides and events All events known to the public API ( AltV.Net.Alt.On... ) and the method OnTick(...) are possible to be called multiple times between OnStart() and OnStop() , since events can occur multiple times and a tick occurs every few milliseconds. 6. OnStop override on resource stop OR graceful server shutdown The last step is the stop of the alt:V server. Keep in mind that OnStop is only called if the resource was stopped manually using the alt:V API or by gracefully stopping the alt:V server. Otherwise, this event will not be executed !",
    "langs": "csharp cs"
  },
  "cs/articles/serialization.html": {
    "type": "article",
    "href": "cs/articles/serialization.html",
    "title": "Serialization",
    "keywords": "Improve this Doc Serialization This article describes how to send custom objects via events. Writable objects This is the easy way to send objects from server to client, because it only supports writing not reading. This only works when you can edit the class you want to send, because you need to add a interface to it. Step 1 Add the IWritable interface to your class. public class MyClass : IWritable { } Step 2 This interface will require you to implement the public void OnWrite(IMValueWriter writer) method. public class MyClass : IWritable { public void OnWrite(IMValueWriter writer) { } } Step 3 Now you can use the writer to write data to it. OnWrite will call automatically when you put a object that is a instance of your class into Alt.Emit, player.Emit ect. This is a simple example of a class only containing a single int. public class MyClass : IWritable { private int myInt; public MyClass(int myInt) { this.myInt = myInt; } public void OnWrite(IMValueWriter writer) { writer.BeginObject(); // We tell the writer to create a object. writer.Name(\"myInt\"); // We tell the writer the next attribute of the object has the name 'myInt'. writer.Value(myInt); // We tell the writer the value for the attribute 'myInt'. writer.EndObject(); // We tell the writer that we are done creating the object. } } Now you can just send a instance of the class. player.Emit(\"myEventName\", new MyClass(42)); This will result in the following js output alt.onServer(\"myEventName\", (myClass) => { alt.log(JSON.stringify(myClass)); alt.log(myClass.myInt); // 42 }) // Console: { \"myInt\": 42 } Step 4 To send arrays its the same logic. public class MyClass2 : IWritable { public void OnWrite(IMValueWriter writer) { writer.BeginObject(); // We tell the writer to create a object. writer.Name(\"myInts\"); // We tell the writer the next attribute of the object has the name 'myInts'. writer.BeginArray(); // We tell the writer the value for the attribute 'myInts' is a array. for (int i = 0;i < 3;i++ { writer.BeginObject(); writer.Name(\"myInt\"); writer.Value(i); writer.EndObject(); } writer.EndArray(); // We tell the writer we are done creating the array writer.EndObject(); // We tell the writer that we are done creating the object. } } Now you can just send a instance of the class. player.Emit(\"myEventName\", new MyClass2()); This will result in the following js output alt.onServer(\"myEventName\", (myClass) => { alt.log(JSON.stringify(myClass)); alt.log(myClass.myInts.length); // 3 alt.log(myClass.myInts[0].myInt); // 0 alt.log(myClass.myInts[1].myInt); // 1 alt.log(myClass.myInts[2].myInt); // 2 for (const obj of myClass.myInts) { alt.log(obj.myInt); } }) // Console: { \"myInts\": [ { \"myInt\": 0 }, { \"myInt\": 1 }, { \"myInt\": 2 }, ] }",
    "langs": "csharp cs js"
  },
  "cs/articles/setup.html": {
    "type": "article",
    "href": "cs/articles/setup.html",
    "title": "Setup",
    "keywords": "Improve this Doc Setup You need the following requirements to use the c# module. Latest .NET Core SDK . Step 1 Download server from https://altv.mp/#/downloads and check c# module and data files. Also make sure to select the operating system where you want to run the server Your server should now look like this: modules/ └── csharp-module.dll resources/ AltV.Net.Host.dll AltV.Net.Host.runtimeconfig.json server.cfg altv-server.exe (altv-server on linux) Now you are ready for creating your first c# resource .",
    "langs": ""
  },
  "cs/articles/trace.html": {
    "type": "article",
    "href": "cs/articles/trace.html",
    "title": "Performance debugging",
    "keywords": "Improve this Doc Performance debugging This article will describe how to debug performance issues in your gamemode. AltTrace The AltV.Net nuget package provides a api to gamemodes for recording trace files. You can only write one trace file at the same time. The following code is starting writing a trace file. AltTrace.Start(\"traceFileName\"); This code stops writing a trace file. AltTrace.Stop(); You can also register a callback to know the size of the trace file while its written. AltTrace.OnTraceFileSizeChange += size => { Console.WriteLine(\"Trace file size:\" + size + \" bytes.\"); }; The trace file will be written to altv server directory. The trace file can be opened via visual studio 2019 or perfview on windows. The easiest way to trigger starting and stopping a trace file recording is to register a server side command. Some sample snippet long currentTraceSize = 0; AltTrace.OnTraceFileSizeChange += size => { currentTraceSize = size; }; Alt.OnConsoleCommand += (name, args) => { switch (name) { case \"trace_start\": if (args.Length != 1) { Console.WriteLine(\"trace_start {name}\"); return; } AltTrace.Start(args[0]); break; case \"trace_stop\": AltTrace.Stop(); break; case \"trace_size\": Console.WriteLine(\"trace file size: \" + currentTraceSize + \" bytes\"); break; } };",
    "langs": "csharp cs"
  },
  "cs/articles/vehicle_create.html": {
    "type": "article",
    "href": "cs/articles/vehicle_create.html",
    "title": "CreateVehicle",
    "keywords": "Improve this Doc CreateVehicle This is a little example how to create Vehicles Serverside in C#. First Example This example will spawn a Adder near you after you died! /* We create our IScript class */ public class AltV_Wiki : IScript { /* We declare & Create our Event Handler. */ [ScriptEvent(ScriptEventType.PlayerDead)] public static void OnPlayerDeath(IPlayer player, IPlayer killer, uint reason) { //We spawn the dead Player player.Spawn(new Position(0, 0, 72)); //We Create a Adder near the local player. IVehicle veh = Alt.CreateVehicle(AltV.Net.Enums.VehicleModel.Adder, new Position(player.Position.X, player.Position.Y + 1.5f, player.Position.Z), player.Rotation); //We notify the Client. player.SendChatMessage(\"You just respawned! Enjoy your Adder.\"); } } Second Example This example shows you how to Create a Command, that spawns a Vehicle. /* We create our IScript class */ public class AltV_Wiki : IScript { [Command(\"createvehicle\")] public static void CreateVehicle(IPlayer player, string VehicleName, int R = 0, int G = 0, int B = 0){ IVehicle veh = Alt.CreateVehicle(Alt.Hash(VehicleName), new Position(player.Position.X, player.Position.Y + 1.5f, player.Position.Z), player.Rotation); //If the Vehicle Creation was successfull, then it should notify you. if (veh != null) { player.SendChatMessage(\"You just Created a \" + VehicleName); } } } Usage //Parameter : (uint model, Position pos, Rotation rotation) Alt.CreateVehicle(AltV.Net.Enums.VehicleModel.Adder, new Position(0, 0, 0), new Rotation(0,0,0));",
    "langs": "csharp cs"
  },
  "cs/articles/vehicle_destroy.html": {
    "type": "article",
    "href": "cs/articles/vehicle_destroy.html",
    "title": "Vehicle destroy event",
    "keywords": "Improve this Doc Vehicle destroy event The vehicle destroy event gets called when a vehicle gets undrivable by e.g. damage or driving into water. Parameter Description vehicle The vehicle that got undrivable Normal event handler Alt.OnVehicleDestroy += (vehicle) => { } IScript event handler // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler. [ScriptEvent(ScriptEventType.VehicleDestroy)] public bool OnVehicleDestroy(IVehicle vehicle) { // We loop through every player on our server and notify them foreach(IPlayer player in Alt.GetAllPlayers()) { // We notify everyone that our Client has joined the Server player.SendChatMessage(\"Vehicle \" + vehicle.Id + \" got destroyed.\"); } } } }",
    "langs": "csharp cs"
  },
  "cs/articles/voice.html": {
    "type": "article",
    "href": "cs/articles/voice.html",
    "title": "General Alt:V Voice",
    "keywords": "Improve this Doc General Alt:V Voice Note : You can´t use the Alt:V Voice without editing your Server.cfg! Before we start... Before we start, we have to edit our Server.CFG File! So we add : voice: {} to initialize our Voice. this would look like that : name: 'alt:V Server' host: 0.0.0.0 port: 7788 players: 128 #password: ultra-password announce: false #token: YOUR_TOKEN gamemode: Freeroam website: example.com language: en // The Voice Initialization voice: {} // <---- We add this to our server.cfg File description: 'alt:V Sample Server' modules: [ csharp-module node-module ] resources: [] Create a Voice Channel & Add Players to it [3D] using AltV.Net; using AltV.Net.Elements.Entities; namespace AltV.Wiki { /* We create our IScript class */ public class AltV_Wiki : IScript { // We Create a Voicechat-Channel & set it to 3D by setting ,, spatial \" to true. public static IVoiceChannel channel = Alt.CreateVoiceChannel(true, 20f); /* We declare & Create our Event Handler. */ /* When a Player connects... it should put the Player into the VoiceChannel. */ [ScriptEvent(ScriptEventType.PlayerConnect)] public void PlayerConnect(IPlayer player, string reason) { /* If a Player Connects... he will be added to our Voice Channel. */ channel.AddPlayer(player); } /* We declare & Create our Event Handler. */ /* When a Player disconnects... it should remove the Player from the VoiceChannel. */ [ScriptEvent(ScriptEventType.PlayerDisconnect)] public void OnPlayerDisconnect(IPlayer client, string reason) { /* If a Player Disconnects... he will be removed from our Voice Channel. */ channel.RemovePlayer(client); } } } How use the Voice now? Open your Alt:V and go to the Header-Point called ,,Settings\". Here you can change your Voice-PushToTalk Buttons & more. Now you can Join a Server which Supports Voice & Play. If you press your Setted Hotkey, your local player will move his mouth if Voice Activition was Successful.",
    "langs": "javascript csharp cs"
  },
  "cs/articles/weapon_damage.html": {
    "type": "article",
    "href": "cs/articles/weapon_damage.html",
    "title": "WeaponDamage",
    "keywords": "Improve this Doc WeaponDamage This is called everytime a player deals damage to another entity with a weapon. Parameter Description player The player that got killed target The target who got damaged by the player weapon The weapon that was used or a other reason https://github.com/FabianTerhorst/coreclr-module/blob/master/api/AltV.Net/Data/Weapons.cs damage The damage that the target received. offset The offset coordinates caused by the weapon damage the target received. Normal event handler Alt.OnWeaponDamage += (player, target, weapon, damage, offset, bodypart) => { // ... return true; // return false will cancel the event and player won't receive damage. } IScript event handler This event will be called if a player deals any damage by a weapon to a other victim. Note : ScriptEvents have to be created in a IScript Class! Otherwise it won´t work! // We create our IScript class public class MyScriptClass : IScript { // We declare and create our event handler [ScriptEvent(ScriptEventType.WeaponDamage)] public static bool WeaponDamage(IPlayer player, IEntity target, uint weapon, ushort damage, Position offset, BodyPart bodyPart) { switch (target) { case IPlayer victim: string aimLevel = bodyPart switch { BodyPart.Head => \"very solid & awesome!\", BodyPart.Chest => \"mysterious like a chest...\", BodyPart.Pelvis => \"evil!\", _ => \"very bad...\" }; player?.SendChatMessage(\"You shot \" + victim.Name + \"! Your aim is \" + aimLevel); return true; default: return false; // <= return false will cancel the event and player won't receive damage. } } }",
    "langs": "csharp cs"
  },
  "cs/index.html": {
    "type": "article",
    "href": "cs/index.html",
    "title": "AltV C# Module",
    "keywords": "Improve this Doc AltV C# Module This is the documentation for the AltV .NET Core module to write server gamemodes in c#. Getting started Look into this guide how to create your first alt:V server gamemode in c#.",
    "langs": ""
  },
  "index.html": {
    "type": "article",
    "href": "index.html",
    "title": "alt:V Documentation",
    "keywords": "Improve this Doc alt:V Documentation alt:V is an alternative multiplayer framework for GTA:V and allows developers and players to player on custom servers. These servers can utilize languages such as C#, JavaScript, and Lua. Here you'll learn how to work with alt:V in these languages, how to properly setup a project and build out your very own gamemode. Some of our features: ✔ Free to use ✔ Slot limits based on hardware ✔ Play with friends ✔ Perfect synchronization ✔ Server browser ✔ Server and client-side ✔ CEF ✔ CDN support ✔ Encrypted client-side code ✔ Built-in voice service up to 500+ users ✔ Mod support ✔ Map support ✔ MLO support ✔ Clothing support ✔ C# ✔ JavaScript ✔ Lua",
    "langs": ""
  },
  "js/api/index.html": {
    "type": "article",
    "href": "js/api/index.html",
    "title": "Alt:V JS module documentation",
    "keywords": "Improve this Doc Alt:V JS module documentation",
    "langs": ""
  },
  "js/articles/create-your-first-resource.html": {
    "type": "article",
    "href": "js/articles/create-your-first-resource.html",
    "title": "Your first resource",
    "keywords": "Improve this Doc Your first resource This article will explain how to create your first resource. General server structure We'll go on by explaining the general server structure and how to add a resource. server/ ├── cache/ ├── data/ ├── modules/ ├── resources/ ├── chat/ ├── freeroam/ ├── voice-chat/ ├── example/ ├── altv-server.exe ├── libnode.dll ├── server.cfg Let's create an example resource. This is the name of your resource: example/ Here go the Client-side Files: example/client/ Here go the Server-side Files: example/server/ Here go the configuration & information: example/resource.cfg Configuring the resource.cfg When you create a resource.cfg, it should look like something similar to this: type: js, main: server/server.js, client-main: client/client.js, client-files: [ client/* ], deps: [ chat ] deps Allows you to require other resources, if they aren't found your resource will fail to load! You can access exported functions & more by adding the following in your code: import chat from 'chat'; main is the main server file. client-main is the first file loaded on Client-side for a player. client-files can usually just contain client/* which will load ALL files. Creating serverside code - server.js Creating Server-side Code - server.js We're going to add chat as a dependency to our resource. Then we're going to import 'alt' and 'chat'. import * as alt from 'alt-server'; import chat from 'chat'; console.log('==> Your Resource Has Loaded! Horray!'); // Called on Server-side alt.on('playerConnect', (player) => { // Logs to the console. alt.log(`==> ${player.name} has connected.`); // Displays message to all players. chat.broadcast(`==> ${player.name} has joined.`); // Sets the player's model. player.model = 'mp_m_freemode_01'; // Spawns the player at coordinates x, y, z, with a delay of 1000 Milliseconds. player.spawn(813, -279, 66, 1000); // Emit to the player passed, the event name, the argument to send. alt.emitClient(player, 'Server:Log', 'hello', 'world'); }); Congrats you've written your first serverside code! That logs to the console Broadcasts to the chat on player join Forces the player to have the freeroam model and spawns them Emits an event to clientside See the clientside section down below to see how to intercept the event on clientside. Creating clientside code - client.js We're going to import two essential alt:V dependencies: natives and alt import * as alt from 'alt-client'; import * as native from 'natives'; alt.log('Client-side has loaded!'); alt.onServer('Server:Log', (msg1, msg2) => { alt.log(`Message From Server: ${msg1}`); alt.log(`Message From Server: ${msg2}`); }); Final Words First of all - Congrats you've written your first clientside code that logs to the 'F8' console => Open the console to see it. Followed by setting up a whole server with basic fundamentals! Word of advice Keep in mind that... alt:V uses ES6 modules the server does not automatically update",
    "langs": "yaml js"
  },
  "js/articles/index.html": {
    "type": "article",
    "href": "js/articles/index.html",
    "title": "Getting Started",
    "keywords": "Improve this Doc Getting Started This is the documentation for getting started with developing JS resources. Read Setup for setting up alt:V. Read Create Resource for information on how to create your first JS resource. Read Understanding Events for an introduction on handling alt:V events. Read Player for an introduction to the player. Read Snippets for useful snippets.",
    "langs": ""
  },
  "js/articles/localstorage.html": {
    "type": "article",
    "href": "js/articles/localstorage.html",
    "title": "Introduction to the LocalStorage",
    "keywords": "Improve this Doc Introduction to the LocalStorage A General Overview The LocalStorage is as the name says local/client-side only . The LocalStorage is a persistent client cached storage. If the player deletes his cache folder the LocalStorage data will get lost! Never use the LocalStorage for sensitive data. Someone could always inject code that reads LocalStorage values! Function Name Description alt.LocalStorage.get Gets the local storage instance. LocalStorage.get Gets the value from the specified key in the local storage.. LocalStorage.set Sets the specified key to the specified value in the local storage. LocalStorage.delete Deletes the specified key from the local storage. LocalStorage.deleteAll Deletes all keys from the local storage. LocalStorage.save Saves the changes to the disk. Set a key .set(key: string, value: any) import * as alt from \"alt-client\"; const storage = alt.LocalStorage.get(); // Gets the local storage instance. storage.set(\"testKey\", \"test\"); // Sets the specified key to the specified value in the local storage. storage.save(); // Saves the changes to the disk. Get a key .get(key: string) import * as alt from \"alt-client\"; const storage = alt.LocalStorage.get(); // Gets the local storage instance. cosnt testKey = storage.get('testKey'); // Gets the value from the specified key in the local storage. alt.log('testKey:', testKey) Delete a key .delete(key: string) import * as alt from \"alt-client\"; const storage = alt.LocalStorage.get(); // Gets the local storage instance. storage.delete(\"testKey\"); // Deletes the specified key from the local storage. storage.save(); // Saves the changes to the disk. Delete all keys .deleteAll() import * as alt from \"alt-client\"; const storage = alt.LocalStorage.get(); // Gets the local storage instance. storage.deleteAll(); // Deletes all keys from the local storage. storage.save(); // Saves the changes to the disk. Example use cases: Store dark / light mode preference Store player custom keybindings Store other small player configurations Store last walkingStyle",
    "langs": "js"
  },
  "js/articles/player/index.html": {
    "type": "article",
    "href": "js/articles/player/index.html",
    "title": "Introduction to the Player",
    "keywords": "Improve this Doc Introduction to the Player The player is you. You are the player. Your friend is the player. Everyone is the player. Player's also come with plenty of properties and functions. Player is most often accessed through events. Meaning an event will give you access to a player instance depending on the behavior from the player. Player Properties Here are some very commonly used properties. This documentation may not reflect all properties available on the player. Server Side Property Name Description armour Set player armour. 0 - 100 currentWeapon Get player's current armour. dimension Player's Virtual World. 0 By Default health Set player's health. 100-200 hwidHash Unique Hardware Hash hwidExHash Unique Ex Hardware Hash id Their server-side id ip Their IP Address model Read or set the player's model. name Readonly Player Set Name ping Current Ping pos Current Player Position vehicle If a vehicle is present this lets you get that vehicle. Null otherwise. socialId A non-unique spoofable social club id. Don't use this for identification. valid A way to determine if the entity still exists. Client Side Property Name Description pos The player's position. If exiting stream range, position is frozen. vehicle The player's vehicle if they're in one. Null if otherwise. scriptID The ped handle of the player. Used for working with natives.",
    "langs": ""
  },
  "js/articles/player/player-script-id.html": {
    "type": "article",
    "href": "js/articles/player/player-script-id.html",
    "title": "Understanding ScriptID",
    "keywords": "Improve this Doc Understanding ScriptID This is a way for us to identify another player or ourselves on client-side . A General Overview A scriptID is unique to only the client side. scriptID will provide us a way to modify the native behavior of a player. They are most often used in tandem with natives. They are unique per client per player. Do not try to share scriptID with another player. It will not work. How to obtain it. Your scriptID for your player can be retrieved in this way. alt.Player.local.scriptID; This is the equivalent of local playerPed = PlayerPedId() from FiveM. However, for individual players it depends on how you receive their player instance. Server Side import * as alt from 'alt-server'; alt.on('playerConnect', player => { // This emits to all player alt.emitClient(null, 'joined', player); }); Client Side import * as alt from 'alt-client'; import * as native from 'natives'; alt.onServer('joined', otherPlayer => { // Check if self. Ignore self. if (otherPlayer === alt.Player.local) { // Let's freeze ourself. // Don't actually do this. This is just how most natives work with scriptID. alt.log(`You have frozen.`); native.freezeEntityPosition(alt.Player.local.scriptID, true); // We'll unfreeze ourself in 5 seconds. alt.setTimeout(() => { alt.log(`You are unfrozen.`); native.freezeEntityPosition(alt.Player.local.scriptID, false); }, 5000); return; } // Log their scriptID to the 'F8' console. alt.log(`Their scriptID is: ${otherPlayer.scriptID}`); });",
    "langs": "js"
  },
  "js/articles/player/server-player-funcs.html": {
    "type": "article",
    "href": "js/articles/player/server-player-funcs.html",
    "title": "Player Server Functions",
    "keywords": "Improve this Doc Player Server Functions This page will act as a representation on using the various player functions. These are meant to be used on server side. addWeaponComponent Used to add a weapon component to a weapon based on its hash. // weaponHash, componentHash player.addWeaponComponent(0xDFE37640, 0x5B3E7DB6) deleteMeta Used to delete server-side meta that is cross-resource available. // Set the player's meta. player.setMeta('cash', 500); // key, value // Check if the meta exists. if (player.hasMeta('cash')) { // key // Get the meta from the player. const currentCash = player.getMeta('cash'); // key // Delete the meta. player.deleteMeta('cash'); // <--- Usage } deleteStreamSyncedMeta Used to delete data stored on the player entity that is accessible on server-side and client-side . This type of synced meta is only accessible by players in streaming range of this player. // Set the player's meta. player.setStreamSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasStreamSyncedMeta('ping')) { // key // Get the meta from the player. const currentCash = player.getStreamSyncedMeta('ping'); // key // Delete the meta. player.deleteStreamSyncedMeta('ping'); // <--- Usage } deleteSyncedMeta Used to delete data stored on the player entity that is accessible on server-side and client-side . This type of synced meta is accessible inside and outside streaming range. // Set the player's meta. player.setSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasSyncedMeta('ping')) { // key // Get the meta from the player. const currentCash = player.getSyncedMeta('ping'); // key // Delete the meta. player.deleteSyncedMeta('ping'); // <--- Usage } destroy You should never use this. It won't do anything and may just crash your server. getMeta Used to get server-side meta that is cross-resource available. // Set the player's meta. player.setMeta('cash', 500); // key, value // Check if the meta exists. if (player.hasMeta('cash')) { // key // Get the meta from the player. const currentCash = player.getMeta('cash'); // <--- Usage // Delete the meta. player.deleteMeta('cash'); // key } getStreamSyncedMeta Used to get data stored on the player entity that is accessible on server-side and client-side . This type of synced meta is only accessible by players inside streaming range of this player. // Set the player's meta. player.setStreamSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasStreamSyncedMeta('ping')) { // key // Get the meta from the player. const currentCash = player.getStreamSyncedMeta('ping'); // <--- Usage // Delete the meta. player.deleteStreamSyncedMeta('ping'); // key } getSyncedMeta Used to delete data stored on the player entity that is accessible on server-side and client-side . This type of synced meta is accessible inside and outside streaming range. // Set the player's meta. player.setSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasSyncedMeta('ping')) { // key // Get the meta from the player. const currentCash = player.getSyncedMeta('ping'); // <--- Usage // Delete the meta. player.deleteSyncedMeta('ping'); // key } giveWeapon Used to give the player a weapon based on hash or appropriate name. // weaponHash, ammoCount, equipThisWeaponNow? player.giveWeapon(1141786504, 1, true); // Get a golf club. hasMeta Used to check if server-side meta is available. This works cross-resource. // Set the player's meta. player.setMeta('cash', 500); // key, value // Check if the meta exists. if (player.hasMeta('cash')) { // <---- Usage // Get the meta from the player. const currentCash = player.getMeta('cash'); // key // Delete the meta. player.deleteMeta('cash'); // key } hasStreamSyncedMeta Used to check if the data stored on the player entity is available. This is accessible on server-side and client-side . This type of synced meta is only accessible by players in streaming range of this player. // Set the player's meta. player.setStreamSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasStreamSyncedMeta('ping')) { // <--- Usage // Get the meta from the player. const currentCash = player.getStreamSyncedMeta('ping'); // key // Delete the meta. player.deleteStreamSyncedMeta('ping'); // key } hasSyncedMeta Used to check if the data stored on the player entity is available. This is accessible on server-side and client-side . This type of synced meta is accessible inside and outside streaming range. // Set the player's meta. player.setSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasSyncedMeta('ping')) { // <--- Usage // Get the meta from the player. const currentCash = player.getSyncedMeta('ping'); // key // Delete the meta. player.deleteSyncedMeta('ping'); // key } kick Used to a kick a player from the server. The reason when supplied to a kick function does not currently show it to the player. You may want to create a work-around that eventually disconnects the user after 5 seconds. alt.on('playerConnect', handleConnect); // Listen for player connections. function handleConnect(player) { player.kick('Bye'); // Kick them instantly. // Kick them eventually. alt.setTimeout(() => { console.log(`${player.name} will be kicked in 5 seconds.`); }, 5000); // 5 seconds. } removeAllWeapons Used to remove all weapons from the player. player.removeAllWeapons(); // Not much else to this. removeWeapon Used to remove a weapon based on its weaponHash. player.removeWeapon(1141786504); // Remove a golf club. removeWeaponComponent Used to remove a weapon component from a player's weapon. // weaponHash, componentHash player.removeWeaponComponent(0xDFE37640, 0x5B3E7DB6) resetNetOwner Restores default functionality of netOwner. Average developers will likely not be using this. setDateTime Used to set the player's current time of day in-game. It is important to understand that time will still continue at whatever the player's current timescale is. It is recommended to freeze the time if you wish for it to stay a certain time. This can be done with the native native.pauseClock(true); on client-side . const currentServerTime = new Date(Date.now()); // day, month, year, hour, minute, second player.setDateTime(date.getDay(), date.getMonth(), date.getFullYear(), date.getHour(), date.getMinute(), date.getSecond()) setMeta Used to set server-side meta on the player. This works cross-resource. // Set the player's meta. player.setMeta('cash', 500); // <--- Usage (key, value) // Check if the meta exists. if (player.hasMeta('cash')) { // key // Get the meta from the player. const currentCash = player.getMeta('cash'); // key // Delete the meta. player.deleteMeta('cash'); // key } setNetOwner Used to change this entities network owner. Average developers will likely not be using this. setStreamSyncedMeta Used to set the data stored on the player entity. This is accessible on server-side and client-side . This type of synced meta is only accessible by players in streaming range of this player. // Set the player's meta. player.setStreamSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasStreamSyncedMeta('ping')) { // <--- Usage // Get the meta from the player. const currentCash = player.getStreamSyncedMeta('ping'); // key // Delete the meta. player.deleteStreamSyncedMeta('ping'); // key } setSyncedMeta Used to set data stored on the player entity that is accessible on server-side and client-side . This type of synced meta is accessible inside and outside streaming range. // Set the player's meta. player.setSyncedMeta('ping', player.ip); // key, value // Check if the meta exists. if (player.hasSyncedMeta('ping')) { // <--- Usage // Get the meta from the player. const currentCash = player.getSyncedMeta('ping'); // key // Delete the meta. player.deleteSyncedMeta('ping'); // key } setWeaponTintIndex Used to set the weapon tint index of a weapon based on its hash. // weaponHash, componentHash player.setWeaponTintIndex(0xDFE37640, 1) spawn Used to respawn the player after they die based on a Vector3 position. The last parameter is used to delay the spawn. // x, y, z, delay player.spawn(0, 0, 0, 0); // Spawn player under the map at 0,0,0",
    "langs": "js"
  },
  "js/articles/player/server-player-props.html": {
    "type": "article",
    "href": "js/articles/player/server-player-props.html",
    "title": "Player Properties",
    "keywords": "Improve this Doc Player Properties This page will act as a representation on using the various player properties. These are meant to be used on server side. player.armour Used to set or get the player's current armour level. const currentArmour = player.armour; player.armour = 5; player.armour += 10; player.armour -= 10; player.authToken Used to get an authToken provided during early auth implementations. Most users will not be utilizing this. alt.on('playerConnect', handleConnect); function handleConnect(player) { if (!player.authToken) { player.kick(`No Auth Token Found`); return; } alt.log(`${player.name}'s authToken is ${authToken}`); } player.currentWeapon Used to set or get the player's current weapon hash. player.currentWeapon = alt.hash('weapon_pistol'); // 0x1B06D571 if (player.currentWeapon === 0x1b06d571) { console.log(`Player has a pistol equipped.`); } If you want to handle all weapon checking server-side in plain English rather than hashes. You should try using a prototype to set and give a player a weapon. alt.Player.prototype.setWeapon = function(weaponName) { this.currentWeapon = alt.hash(weaponName); this.currentWeaponName = weaponName; }; player.currentWeaponComponents Used to get all weapon components that are currently on a player's currently equipped weapon. All weapon components are hashed. const currentWeaponComponents = player.currentWeaponComponents; for (let i = 0; i < currentWeaponComponents.length; i++) { const weaponComponentHash = currentWeaponComponents[i]; } player.currentWeaponTintIndex Used to get the currently equipped weapon's tint index. const currentTint = player.currentWeaponTintIndex; player.dimension Used to get or set the player's current dimension. Dimensions are based on INT32. Which means there is a minimum and maximum value for a dimension. From -2147483648 to 2147483648 . A description for dimensions written by Heron is as follows. X can see only X -X can see 0 and -X 0 can't see -X and X The default dimension is 0 . const currentDimension = player.dimension; player.dimension = 1; // If you need a unique instance per player join. This is a decent way to handle it. // Just remember to set it back to zero after you do whatever you need to do in a unique dimension. player.dimension = player.id; player.entityAimOffset Used to get the player's current aim offset. There is currently not existing use case for this specific function. At the time of writing this document we're not even sure if it's functioning. player.entityAimingAt Used to get the player's current entity they are aiming at. The current sentiment is that this specific property does not work. At the time of writing this document we're not even sure if it's functioning. player.flashlightActive Used to get the player's flashlight activity? At the time of writing this document we're not even sure if it's functioning. player.health Used to get or set the player's current health. Health in GTA:V is based on the values 100 - 200 . 200 is the player's maximum health. < 100 means the player is dead. const currentHealth = player.health; player.health += 10; if (player.health > 200) { player.health = 200; } // Kill the player. player.health = 0; player.hwidExHash This is one of two ways to get a unique hardware hash that belongs to the player. This is a great way to ban a player; especially when they'll need a whole new set of hardware to get past your ban. Nobody currently knows the way this hardware information is determined. const currentHwidEx = player.hwidExHash; player.hwidHash This is one of two ways to get a unique hardware hash that belongs to the player. This is a great way to ban a player; especially when they'll need a whole new set of hardware to get past your ban. Nobody currently knows the way this hardware information is determined. const currentHwid = player.hwidHash; player.id Used to get the player's current id. These are strictly unique to the join order of a player. ID's may be used up to the value 65535 . After reaching 65,535 the id is recycled to a new joiner. alt.on('playerConnect', handleConnect); function handleConnect(player) { alt.log(`${player.name} has joined with the ID of ${player.id}`); } player.ip In most cases this is an IP that is converted from IPv4 to IPv6. An example of what a local host IP looks like: ::ffff:127.0.0.1 alt.on('playerConnect', handleConnect); function handleConnect(player) { if (player.ip === `::ffff:127.0.0.1`) { alt.log(`${player.name} has joined from local host.`); } } player.maxArmour Used to set or get the player's current maximum armour. The maximum value this can be set to is 65535 . After setting this you can set the player's current armour to the maximum armour value. const currentMaxArmour = player.maxArmour; if (currentMaxArmour <= 100) { player.maxArmour = 65535; player.armour = 65535; } alt.log(`${player.name} is a chunker.`); player.maxHealth Used to set or get the player's current maximum health. The maximum value this can be set to is 65535. After setting this you can set the player's current health to the maximum health value. const currentMaxHealth = player.maxHealth; if (currentMaxHealth <= 100) { player.maxHealth = 65535; player.health = 65535; } alt.log(`${player.name} is a healthy chunker.`); player.model Used to set set or get the player's current model. You may pass a string value here. No model is set automatically and should be set when the player is connected or authenticated. alt.on('playerConnect', handleConnect); function handleConnect(player) { player.model = 'mp_m_freemode_01'; } player.name Used to get the player's current name. This is set by the player in their options. alt.on('playerConnect', handleConnect); function handleConnect(player) { if (player.name.toLowerCase() === 'stuyk') { player.kick(`Stupid name.`); } } player.netOwner Used to get the current network owner responsible for syncing an entity with the server. Inherited from entity. This is not necessarily a useful property for the average developer. const currentOwner = player.netOwner; if (!currentOwner) { console.log(`Looks like nobody owns this entity.`); } player.ping Used to get the player's current ping. Below is a snippet to make player ping accessible by all players. alt.setInterval(handlePingUpdate, 5000); function handlePingUpdate() { const currentPlayers = [...alt.Player.all]; for (let i = 0; i < currentPlayers.length; i++) { const player = currentPlayers[i]; if (!player || !player.valid) { continue; } player.setSyncedMeta('ping', player.ping); } } player.pos Used to get or set the player's current position. When getting the player's current position you should use a spread operator to make it modifiable. const currentPos = { ...player.pos }; currentPos.x += 1; // Teleport them under the map. player.pos = { x: 0, y: 0, z: 0 }; // Create a Vector3 with the alt function. player.pos = new alt.Vector3(0, 0, 0); player.rot Used to get or set the player's current rotation. However, setting rotation is broken on server-side . const currentRot = { ...player.rot }; player.seat Used to get the current seat that the player is in. if (player.vehicle && player.seat === -1) { alt.log(`Player is in the driver's seat.`); // Front Left } if (player.vehicle && player.seat === 0) { alt.log(`Player is riding shotgun.`); // Passenger. Right side. } if (player.vehicle && player.seat === 1) { alt.log(`Player is behind the driver's seat.`); // Back Left } if (player.vehicle && player.seat === 2) { alt.log(`Player is behind the player riding shotgun.`); // Back Right } player.socialId Used to get a non-safe version of a player's current social club identification that is linked to their Rockstar account. Keep in mind that this value IS NOT SAFE do not use it for authentication. IT CAN BE SPOOFED . const social = player.socialId; player.valid Used to get if a player entity is still valid. This is useful when using timeouts, intervals, and handling disconnect events. A player that invalid means that it can longer receive data from the server. alt.on('playerDisconnect', handleDisconnect); function handleDisconnect(player, reason) { if (!player || !player.valid) { console.log(`Looks like this player is already invalid. Can't save anything.`); return; } console.log(`${player.name} has disconnected.`); } player.vehicle Used to get the current vehicle that the player is inside. Returns null or undefined if the player is NOT in a vehicle. if (player.vehicle) { console.log(`Player is in a vehicle. Let's change its color!`); player.vehicle.setPrimaryColor = { r: 255, g: 0, b: 0, a: 255 }; } if (!player.vehicle) { console.log(`Player is not in a vehicle.`); }",
    "langs": "js"
  },
  "js/articles/setup.html": {
    "type": "article",
    "href": "js/articles/setup.html",
    "title": "Setting up an alt:V server with the JS module",
    "keywords": "Improve this Doc Setting up an alt:V server with the JS module This article will explain how to setup an alt:V server with the JS module. Requirements Latest Version of NodeJS A Code Editor (Visual Studio Code, Sublime Text etc.) Basic knowledge of command prompts VS Redist Latest Version installed Windows 10 or Linux (For running the server) Summary If you are interested in learning all of the ins and outs of getting a server setup please follow this tutorial entirely. If you are more interested in getting a server running in a few minutes check out alt:V Quickstart repository and follow those instructions. Obtaining the server files Download the latest build here. Within the Dropdown navigate to: Release , Release candidate OR Development *. *For development, most of the time the branch release candidate is used. Tick the following elements: [x] Data Files [x] JS Module [ ] C# Module [x] Sample Config File [x] Example Resource Pack Press DOWNLOAD and once you're done => Extract the .zip with your preferred program (7-Zip, Winrar, etc.)* *Into a folder that is not on your Desktop! Running the server Depending on your chosen Code Editor, you may consider the following options: Visual Studio Code - Within VSC, open the Server Root (File > Open Folder) - Create a new Terminal (Terminal > New Terminal ) Once you archieved to have a Terminal, it's up to you: For PowerShell: - Select the Prompt PowerShell - Type > ./altv-server.exe For Command Prompt: - Select the Command Prompt - Type > altv-server.exe Congrats, your server is now running - Press CTRL + C to stop the server. - Press arrow up and press enter simply restart the server. PowerShell - Navigate to the root folder of your altv-server.exe - Head to the adress bar of the file explorer - Type > powershell - Type > ./altv-server.exe Congrats, your server is now running - Press CTRL + C to stop the server. - Press arrow up and press enter simply restart the server. Command Prompt Just run altv-server.exe Configuring your client for development Navigate to your root of alt:V Client View altv.cfg in your preferred editor Now something similar to this should appear: branch: 'rc' build: '1182' debug: 'true' gtapath: 'D:\\\\Program Files (x86)\\\\Steam\\\\steamapps\\\\common\\\\Grand Theft Auto V' ignoreLowPriorityProps: 'false' lang: 'en' lastip: '' name: 'YourWonderfulName' netgraph: 'false' streamerMode: 'false' voiceActivationEnabled: 'false' voiceActivationKey: '78' voiceEnabled: 'true' voiceInputSensitivity: '20' voiceVolume: '100' Using branches Set your branch based on what you've choose in Obtaining the Server Files . Branch names: release release candidate dev Release: branch: 'release' Release candidate (Mostly used): branch: 'rc' Development: branch: 'dev' Using debug mode (client) Edit the altv.cfg in the directory of your alt:V installation and add the following: debug: true This allows the usage of several debug features like reconnect etc. with your F8 console. Configuring the server.cfg Once you're done changing the stated things above, it's time to head to the server again. The server.cfg is where the magic happens, here you can change what is most important. Once opened, something similar to this should appear: name: 'alt:V Server' host: 0.0.0.0 port: 7788 players: 128 #password: ultra-password announce: false #token: YOUR_TOKEN gamemode: Freeroam website: example.com language: en description: 'alt:V Sample Server' modules: [ js-module ] resources: [ ] Using debug mode (server) While you are developing make sure you ENABLE the following inside the server.cfg. Add this to your config: debug: true Once enabled, you can now use several debug commands like: restart [RESOURCE] stop [RESOURCE] start [RESOURCE] reconnect * *Reconnect can cause bugs and issues, this is an experimental feature and only meant to be used in development. Adding resources Adding a resource is as simple as putting the folders name inside of the resources array. No commas necessary - But you can add them if you want. Right now, your resource array is empty. Keep in mind, as you've chosen the Example Resource Pack you've got three example resources. Load them, by simple adding the folder names* *The name is case sensitive! - Also templating with [resourceName] isn't gonna work as seen in other multiplayer modifications. resources: [ freeroam chat newResource ]",
    "langs": "md yaml"
  },
  "js/articles/snippets/encryption.html": {
    "type": "article",
    "href": "js/articles/snippets/encryption.html",
    "title": "Encryption / Password Hashing",
    "keywords": "Improve this Doc Encryption / Password Hashing This requires a library called sjcl . This will let you perform a PBKDF2 encryption. You can install it in your package.json by doing: npm install sjcl Server Side import sjcl from 'sjcl'; /** * Hash a password with pbkdf2 * @param {string} password * @returns {string} A password hash. */ export function encryptPassword(password) { const saltBits = sjcl.random.randomWords(2, 0); const salt = sjcl.codec.base64.fromBits(saltBits); const key = sjcl.codec.base64.fromBits(sjcl.misc.pbkdf2(password, saltBits, 2000, 256)); return `${key}$${salt}`; } /** * Verify a password matches with pbkdf2. * @param {string} password * @param {string} storedPasswordHash * @returns {bool} true if correct password */ export function verifyPassword(password, storedPasswordHash) { const [_key, _salt] = storedPasswordHash.split('$'); const saltBits = sjcl.codec.base64.toBits(_salt); const derivedKey = sjcl.misc.pbkdf2(password, saltBits, 2000, 256); const derivedBaseKey = sjcl.codec.base64.fromBits(derivedKey); if (_key != derivedBaseKey) { return false; } return true; } /** * Generate a hash based on string. * @param {string} data */ export function generateHash(data) { let hashBytes = sjcl.hash.sha256.hash(data + Math.random(0, 900000000)); return sjcl.codec.hex.fromBits(hashBytes); } /** * Generate a persistent hash based on string. * @param {string} data */ export function persistentHash(data) { let hashBytes = sjcl.hash.sha256.hash(data); return sjcl.codec.hex.fromBits(hashBytes); } Example Usage Server Side const hash = encryptPassword('test'); const isCorrectPassword = verifyPassword('test', hash); if (isCorrectPassword) { console.log(`That was a correct password.`); } const randomDataHash = generateHash(`whatever ${hash} ${isCorrectPassword}`); console.log(randomDataHash); const persistent = persistentHash(`whatever`); const persistent2 = persistentHash(`whatever`); if (persistent === persistent2) { console.log(`they match!`); }",
    "langs": "js"
  },
  "js/articles/snippets/helptext.html": {
    "type": "article",
    "href": "js/articles/snippets/helptext.html",
    "title": "Help Text",
    "keywords": "Improve this Doc Help Text Help text is the little box that appears in the upper left corner of your game. You cannot change the position of this text. Client Side alt.onServer('showHelpText', showHelpText); export function showHelpText(text, milliseconds) { native.beginTextCommandDisplayHelp('STRING'); native.addTextComponentScaleform(text); native.endTextCommandDisplayHelp(0, 0, 0, milliseconds); } Example Usage Server Side alt.on('playerConnect', player => { alt.emitClient(player, 'showHelpText', 'Press ~INPUT_MOVE_UP_ONLY~ to move forward.', 5000); }); Client Side showHelpText('Press ~INPUT_MOVE_UP_ONLY~ to move forward.', 5000);",
    "langs": "js"
  },
  "js/articles/snippets/index.html": {
    "type": "article",
    "href": "js/articles/snippets/index.html",
    "title": "About Snippets",
    "keywords": "Improve this Doc About Snippets These are general snippets that will assist with understanding some functionality for server building. Use the sidebar on the left to browse the snippets in the cookbook.",
    "langs": ""
  },
  "js/articles/snippets/markers.html": {
    "type": "article",
    "href": "js/articles/snippets/markers.html",
    "title": "Markers",
    "keywords": "Improve this Doc Markers Markers are those slightly transparent objects in the 3D world that you can walk or drive through. Client Side /** * Draw a marker. Requires alt.everyTick or alt.setInterval * * @param {number} type * @param {alt.Vector3} pos * @param {alt.Vector3} dir * @param {alt.Vector3} rot * @param {alt.Vector3} scale * @param {number} r * @param {number} g * @param {number} b * @param {number} alpha */ export function drawMarker(type, pos, dir, rot, scale, r, g, b, alpha) { native.drawMarker( type, pos.x, pos.y, pos.z, dir.x, dir.y, dir.z, rot.x, rot.y, rot.z, scale.x, scale.y, scale.z, r, g, b, alpha, false, true, 2, false, undefined, undefined, false ); } Example Usage Client Side alt.everyTick(() => { drawMarker(1, new alt.Vector3(25, 2, 1), new alt.Vector3(0, 0, 0), new alt.Vector3(1, 1, 1), 255, 0, 0, 100); });",
    "langs": "js"
  },
  "js/articles/snippets/math.html": {
    "type": "article",
    "href": "js/articles/snippets/math.html",
    "title": "Math & Distance Utility Functions",
    "keywords": "Improve this Doc Math & Distance Utility Functions alt:V by default does not come with default functions for getting distance. Use these functions on server-side or client-side. /** * Get all players in a certain range of a position. * @param {} pos * @param {} range * @param {} dimension=0 * @returns {Array<alt.Player>} */ export function getPlayersInRange(pos, range, dimension = 0) { if (pos === undefined || range === undefined) { throw new Error('GetPlayersInRange => pos or range is undefined'); } return alt.Player.all.filter(player => { return player.dimension === dimension && distance2d(pos, player.pos) <= range; }); } /** * Get the forward vector of a player. * @param {} rot * @returns {{x,y,z}} */ export function getForwardVectorServer(rot) { const z = -rot.z; const x = rot.x; const num = Math.abs(Math.cos(x)); return { x: -Math.sin(z) * num, y: Math.cos(z) * num, z: Math.sin(x) }; } /** * Get the distance from one vector to another. * Does take Z-Axis into consideration. * @param {} vector1 * @param {} vector2 * @returns {number} */ export function distance(vector1, vector2) { if (vector1 === undefined || vector2 === undefined) { throw new Error('AddVector => vector1 or vector2 is undefined'); } return Math.sqrt( Math.pow(vector1.x - vector2.x, 2) + Math.pow(vector1.y - vector2.y, 2) + Math.pow(vector1.z - vector2.z, 2) ); } /** * Get the distance from one vector to another. * Does not take Z-Axis into consideration. * @param {} vector1 * @param {} vector2 * @returns {{x,y,z}} */ export function distance2d(vector1, vector2) { if (vector1 === undefined || vector2 === undefined) { throw new Error('AddVector => vector1 or vector2 is undefined'); } return Math.sqrt(Math.pow(vector1.x - vector2.x, 2) + Math.pow(vector1.y - vector2.y, 2)); } /** * Check if a position is between two vectors. * @param {} pos * @param {} vector1 * @param {} vector2 * @returns {boolean} */ export function isBetween(pos, vector1, vector2) { const validX = pos.x > vector1.x && pos.x < vector2.x; const validY = pos.y > vector1.y && pos.y < vector2.y; return validX && validY ? true : false; } /** * Get a random position around a position. * @param {} position * @param {} range * @returns {{x,y,z}} */ export function randomPositionAround(position, range) { return { x: position.x + Math.random() * (range * 2) - range, y: position.y + Math.random() * (range * 2) - range, z: position.z }; } /** * Get the closest vector from a group of vectors. * @param {alt.Vector3} pos * @param {Array<{x,y,z}> | Array<{pos:alt.Vector3}} arrayOfPositions * @returns {Array<any>} */ export function getClosestVectorFromGroup(pos, arrayOfPositions) { arrayOfPositions.sort((a, b) => { if (a.pos && b.pos) { return distance(pos, a.pos) - distance(pos, b.pos); } return distance(pos, a.pos) - distance(pos, b.pos); }); return arrayOfPositions[0]; } /** * Get the closest player to a player. * @param {} player * @returns {Array<alt.Player>} */ export function getClosestPlayer(player) { return getClosestVectorFromGroup(player.pos, [...alt.Player.all]); } /** * Get the closest vehicle to a player. * @param {alt.Vector3} player * @returns {Array<alt.Vehicle>} */ export function getClosestVehicle(player) { return getClosestVectorFromGroup(player.pos, [...alt.Vehicle.all]); } Example Usage const dist1 = { x: 5, y: 2, z: 0 }; const dist2 = { x: 1, y: 1, z: 0 }; const dist = distance2d(dist1, dist2); const closestVehicle = getClosestVehicle(player); const closestPlayer = getClosestPlayer(player);",
    "langs": "js"
  },
  "js/articles/snippets/notifications.html": {
    "type": "article",
    "href": "js/articles/snippets/notifications.html",
    "title": "Notifications",
    "keywords": "Improve this Doc Notifications Notifications are the black boxes that appear above your map on bottom left-hand side. They are only accessible from client-side but you can call them from server-side. See the example below on how to utilize this in two different ways. Client Side alt.onServer('drawNotification', drawNotification); export function drawNotification(imageName, headerMsg, detailsMsg, message) { native.beginTextCommandThefeedPost('STRING'); native.addTextComponentSubstringPlayerName(message); native.endTextCommandThefeedPostMessagetextTu( imageName.toUpperCase(), imageName.toUpperCase(), false, 4, headerMsg, detailsMsg, 1.0, '' ); native.endTextCommandThefeedPostTicker(false, false); } Example Usage Server Side alt.emitClient(player, 'drawNotification', 'CHAR_AMMUNATION', 'Header', 'Small Details', 'The rest of the owl.'); Client Side drawNotification('CHAR_AMMUNATION', 'Header', 'Small Details', 'The rest of the owl.');",
    "langs": "js"
  },
  "js/articles/snippets/prototyping.html": {
    "type": "article",
    "href": "js/articles/snippets/prototyping.html",
    "title": "Prototyping",
    "keywords": "Improve this Doc Prototyping Prototyping allows you to extend default class functionality for Player's, Vehicle's, etc. It is important to understand that all Prototype files should be loaded immediately after your database initialization. Granted your Prototype has database features. They do NOT work in multiple resources. Single resource only. This means that the data for a prototype is non-transferrable between resources. JavaScript Server Side Example alt.Player.prototype.emitMeta = function emitMeta(key, value) { if (typeof value === 'function') { throw new Error(`Value cannot be a function. emitMeta.prototype`); } this.setMeta(key, value); alt.emitClient(this, 'meta:Emit', key, value); }; alt.Player.prototype.init = function init() { this.data = {}; }; alt.Player.prototype.syncCash = function syncCash() { this.emitMeta('cash', this.data.cash); }; alt.Player.prototype.setCash = function setCash(value) { if (isNaN(value)) { throw new Error(`Value is not a number. setCash.prototype`); } if (!this.data) { this.data = {}; } this.data.cash = value; this.syncCash(); }; alt.Player.prototype.subCash = function subCash(value) { if (isNaN(value)) { throw new Error(`Value is not a number. subCash.prototype`); } if (!this.data) { this.data = {}; } const absValue = Math.abs(parseFloat(value)) * 1; if (this.data.cash < absValue) { return false; } this.data.cash -= absValue; this.data.cash = Number.parseFloat(this.data.cash).toFixed(2) * 1; this.syncCash(); return true; }; alt.Player.prototype.addCash = function addCash(value) { if (isNaN(value)) { throw new Error(`Value is not a number. addCash.prototype`); } if (!this.data) { this.data = {}; } const absValue = Math.abs(parseFloat(value)); if (this.data.cash + absValue > 92233720368547757) { absValue = 92233720368547757; } this.data.cash += absValue; this.data.cash = Number.parseFloat(this.data.cash).toFixed(2) * 1; this.syncCash(); return true; }; Typescript Server Side Example // Use `alt-client` to do prototyping on client-side. declare module 'alt-server' { export interface Player { cash?: number; bank?: number; // You must declare your function interfaces. addToCash(value: number): boolean; addToBank(value: number): boolean; } } // Then you can define your prototype functions. alt.Player.prototype.addToCash = function addToCash(value: number) { if (!this.cash) { this.cash = value; } else { this.cash += value; } return true; }; alt.Player.prototype.addToBank = function addToBank(value: number) { if (!this.bank) { this.bank = value; } else { this.bank += value; } return true; }; Example Usage Server Side player.init(); player.emitMeta('test', true); player.setCash(25); player.subCash(5); player.addCash(2);",
    "langs": "js typescript ts javascript"
  },
  "js/articles/snippets/shuffle.html": {
    "type": "article",
    "href": "js/articles/snippets/shuffle.html",
    "title": "Shuffle Array",
    "keywords": "Improve this Doc Shuffle Array If you find yourself ever needing to shuffle an array. Here's a simple exported function to shuffle your array. export function shuffle(array) { var currentIndex = array.length; var temporaryValue, randomIndex; while (0 !== currentIndex) { // Pick a remaining element... randomIndex = Math.floor(Math.random() * currentIndex); currentIndex -= 1; // And swap it with the current element. temporaryValue = array[currentIndex]; array[currentIndex] = array[randomIndex]; array[randomIndex] = temporaryValue; } return array; } Example Usage const myArray = [1, 2, 3, 4, 5]; const result = shuffle(myArray); console.log(result);",
    "langs": "js"
  },
  "js/articles/snippets/textlabels.html": {
    "type": "article",
    "href": "js/articles/snippets/textlabels.html",
    "title": "Drawing Text 3D & 2D",
    "keywords": "Improve this Doc Drawing Text 3D & 2D Used to draw text on your screen or in a 3D space. This only works on client-side . Client Side export function drawText2d( msg, x, y, scale, fontType, r, g, b, a, useOutline = true, useDropShadow = true, layer = 0, align = 0 ) { let hex = msg.match('{.*}'); if (hex) { const rgb = hexToRgb(hex[0].replace('{', '').replace('}', '')); r = rgb[0]; g = rgb[1]; b = rgb[2]; msg = msg.replace(hex[0], ''); } native.beginTextCommandDisplayText('STRING'); native.addTextComponentSubstringPlayerName(msg); native.setTextFont(fontType); native.setTextScale(1, scale); native.setTextWrap(0.0, 1.0); native.setTextCentre(true); native.setTextColour(r, g, b, a); native.setTextJustification(align); if (useOutline) { native.setTextOutline(); } if (useDropShadow) { native.setTextDropShadow(); } native.endTextCommandDisplayText(x, y); } export function drawText3d( msg, x, y, z, scale, fontType, r, g, b, a, useOutline = true, useDropShadow = true, layer = 0 ) { let hex = msg.match('{.*}'); if (hex) { const rgb = hexToRgb(hex[0].replace('{', '').replace('}', '')); r = rgb[0]; g = rgb[1]; b = rgb[2]; msg = msg.replace(hex[0], ''); } native.setDrawOrigin(x, y, z, 0); native.beginTextCommandDisplayText('STRING'); native.addTextComponentSubstringPlayerName(msg); native.setTextFont(fontType); native.setTextScale(1, scale); native.setTextWrap(0.0, 1.0); native.setTextCentre(true); native.setTextColour(r, g, b, a); if (useOutline) { native.setTextOutline(); } if (useDropShadow) { native.setTextDropShadow(); } native.endTextCommandDisplayText(0, 0); native.clearDrawOrigin(); } Example Usage Client Side alt.everyTick(() => { drawText2d('Hello from Top Center of Screen', 0.5, 0.05, 0.4, 4, 255, 255, 255, 255); const playerPos = { ...alt.Player.local.pos }; drawText3d(`This is You`, playerPos.x, playerPos.y, playerPos.z, 0.3, 4, 255, 255, 255, 255); });",
    "langs": "js"
  },
  "js/articles/snippets/voice.html": {
    "type": "article",
    "href": "js/articles/snippets/voice.html",
    "title": "Voice (Utilize alt:V´s built in Voice)",
    "keywords": "Improve this Doc Voice (Utilize alt:V´s built in Voice) alt:V by default has a built in Voice functionality and this is how you can use it. This voice can be used for 3D or 2D Voice solutions to ship features like: 3D & 2D Voicechat Phonecalls Radio communication much more The snippet below will show you how to implement 3D voice for roleplay servers with javascript class usage Functional Explanation Quick explanation for what voice functionality is available through the alt:V API Player properties (clientside) isTalking boolean - which will be true if player is talking micLevel number - player talking volume import * as alt from 'alt-client'; let localPlayer = alt.Player.local; alt.log('Is player talking: ' + localPlayer.isTalking); alt.log('Player talking volume: ' + localPlayer.micLevel); VoiceChannel Class new VoiceChannel(isSpatial: boolean, maxDistance: number) constructor - isPatial false means global voice channel,isPatial true means 3D voice channel which uses maxDistance as range addPlayer(player: alt.Player) function - adds a player to the specific channel removePlayer(player: alt.Player) function - removes a player to the specific channel mutePlayer(player: alt.Player) function - mute the player inside the specific channel unmutePlayer(player: alt.Player) function - unmute the player inside the specific channel isPlayerInChannel(player: alt.Player) function - checks if the player is already in the specific channel isPlayerMuted(player: alt.Player) function - checks if the player is muted in the specific channel import * as alt from 'alt-server'; let testChannel = new alt.VoiceChannel(true, 20); alt.on('playerConnect', player => { testChannel.addPlayer(player); testChannel.unmutePlayer(player); }); alt.on('playerDisconnect', player => { testChannel.removePlayer(player); }); alt.on('playerDeath', player => { //mute player in testchannel if dead and connected to voice if (testChannel.isPlayerInChannel(player) && !testChannel.isPlayerMuted(player)) { testChannel.mutePlayer(player); } }); //check example Example Usage 3D (Serverside) Serverside import * as alt from 'alt-server'; class AltvVoiceServerModule { constructor() { //yell channel this.longRangeChannel = new alt.VoiceChannel(true, 16); //speak channel this.midRangeChannel = new alt.VoiceChannel(true, 8); //whisper channel this.lowRangeChannel = new alt.VoiceChannel(true, 3); this.registerEvents(); alt.log('AltvVoiceServerModule init'); } registerEvents() { //alternatively call it after player succesfully spawned after authentication alt.on('playerConnect', player => { this.addToVoiceChannels(player); this.changeVoiceRange(player); }); //handle player disconenct alt.on('playerDisconnect', this.removePlayerFromChannels.bind(this)); //handle player gamecrash/entity invalidity alt.on('removeEntity', this.removePlayerFromChannels.bind(this)); //handle player voicerange change alt.onClient('server:ChangeVoiceRange', this.changeVoiceRange.bind(this)); } /** * clear channels for given player * @param {alt.Player} player * @returns {null} */ removePlayerFromChannels(player) { if (this.lowRangeChannel.isPlayerInChannel(player)) { this.lowRangeChannel.removePlayer(player); } if (this.midRangeChannel.isPlayerInChannel(player)) { this.midRangeChannel.removePlayer(player); } if (this.longRangeChannel.isPlayerInChannel(player)) { this.longRangeChannel.removePlayer(player); } } /** * add player to all voice channels * @param {alt.Player} player * @returns {null} */ addToVoiceChannels(player) { this.lowRangeChannel.addPlayer(player); this.midRangeChannel.addPlayer(player); this.longRangeChannel.addPlayer(player); } /** * mute player in all voice channels * @param {alt.Player} player * @returns {null} */ muteInAllChannels(player) { this.lowRangeChannel.mutePlayer(player); this.midRangeChannel.mutePlayer(player); this.longRangeChannel.mutePlayer(player); } /** * takes a range for a player and mutes this player in all channels he shouldn´t be heard * @param {alt.Player} player * @param {number} range * @returns {null} */ muteNotInRangeChannels(player, range) { switch (range) { case 3: this.midRangeChannel.mutePlayer(player); this.longRangeChannel.mutePlayer(player); break; case 8: this.lowRangeChannel.mutePlayer(player); this.longRangeChannel.mutePlayer(player); break; case 15: this.lowRangeChannel.mutePlayer(player); this.midRangeChannel.mutePlayer(player); break; default: break; } } /** * change the voice range of the given player and unmute in new range channel * @param {alt.Player} player * @returns {null} */ changeVoiceRange(player) { if (!player.voiceRange) { player.voiceRange = 0; } switch (player.voiceRange) { case 0: player.voiceRange = 3; this.muteNotInRangeChannels(player, 3); this.lowRangeChannel.unmutePlayer(player); alt.emitClient(player, 'client:UpdateCurrentAltVoiceRange', 3); break; case 3: player.voiceRange = 8; this.muteNotInRangeChannels(player, 8); this.midRangeChannel.unmutePlayer(player); alt.emitClient(player, 'client:UpdateCurrentAltVoiceRange', 8); break; case 8: player.voiceRange = 15; this.muteNotInRangeChannels(player, 15); this.longRangeChannel.unmutePlayer(player); alt.emitClient(player, 'client:UpdateCurrentAltVoiceRange', 15); break; case 15: player.voiceRange = 0; this.muteInAllChannels(player); alt.emitClient(player, 'client:UpdateCurrentAltVoiceRange', 0); break; default: break; } } } //initilize voice class instance export const AltvVoiceServerModuleInstance = new AltvVoiceServerModule(); Example Usage 3D (Clientside) Clientside import * as alt from 'alt-client'; class AltvVoiceClientModule { constructor() { //localPlayer object shortcut this.localPlayer = alt.Player.local; //interval to check state changes this.interval = null; //cached talking state this.talkingState = false; //cached voice range this.currentRange = 0; this.registerEvents(); alt.log('AltvVoiceClientModule init'); } registerEvents() { alt.on('keydown', key => { if (key == 107) { //Press Num+ to change the range in which you get heard by other players alt.emitServer('server:ChangeVoiceRange'); } }); alt.onServer('client:UpdateCurrentAltVoiceRange', range => { this.currentRange = range; //emit new range to your user interface /* example payload { muted: range === 0 ? true : false, range: range } */ }); this.registerTalkingInterval(); } /* * interval to handle talking state changes * i.e show in your ui if this player is talking (like ts3 voice led) */ registerTalkingInterval() { this.interval = alt.setInterval(() => { //only emit if state changed if (this.talkingState !== this.localPlayer.isTalking && this.currentRange !== 0) { this.talkingState = this.localPlayer.isTalking; //emit talking state change to your ui {this.talkingState} } if (this.talkingState && this.currentRange === 0) { //emit talking state change to your ui {false} } }, 444); } } //initilize voice class instance export const AltvVoiceClientModuleInstance = new AltvVoiceClientModule();",
    "langs": "js"
  },
  "js/articles/understanding-events.html": {
    "type": "article",
    "href": "js/articles/understanding-events.html",
    "title": "Events",
    "keywords": "Improve this Doc Events Events work in a very specific way and understanding their communication is very important. Server can talk to any client. Client may only talk to WebViews and the Server. A client CANNOT talk to another client. Function Name Description alt.emit Emit an event on server or client side. Only received on the side it was emitted from. alt.on Receives an event. Server only receives server events. Client only receives client events. alt.onServer Receives an event emitted from the server on client-side. Triggered with alt.emitClient . alt.emitClient Emit an event to a specific client that they receive with alt.onServer . alt.onClient Receives an event emitted from the client on server-side. Triggered with alt.emitServer . alt.emitServer Emit an event to the server that is received with alt.onClient . Server to Client The server may only emit data to the client-side with emitClient which requires a Player. However, a player can also be substituted for null which will emit to all players. Server Side alt.on('playerConnect', player => { alt.emitClient(player, 'sayHello'); }); Client Side alt.onServer('sayHello', () => { alt.log('Hello from server.'); }); Client to Server The client may only emit data to the server-side with emitServer. The server-side onServer event will automatically receive a Player in their event handler. Client Side alt.on('connectionComplete', () => { alt.emitServer('sayHello'); }); Server Side alt.onClient('sayHello', player => { alt.log(`${player.name} is saying hello`); }); Server Resource to Server Resource The server may only communicate with itself with on and emit functions. The client may only communicate with itself with on and emit functions. They speak across resources as well. Server Side alt.emit('hello', 'this is a message'); alt.on('hello', msg => { alt.log(msg); }); Client Resource to Client Resource Client Side alt.emit('hello', 'this is a message'); alt.on('hello', msg => { alt.log(msg); }); Client to WebView and Back Note: Resource in the HTTP address refers to the resource that you are currently writing code for. Client Side const webview = new alt.WebView('http://resource/client/html/index.html'); webview.on('test2', handleFromWebview); function handleFromWebview(msg) { alt.log(msg); } alt.setTimeout(() => { webview.emit('test', 'Hello from Client'); }, 500); Client Side HTML Page <html> <head> <title>Hello World</title> </head> <body> <p>Words</p> <script type=\"text/javascript\"> if ('alt' in window) { alt.on('test', msg => { console.log(msg); alt.emit('test2', 'hello from webview'); }); } </script> </body> </html>",
    "langs": "js html"
  },
  "js/articles/vscode-setup.html": {
    "type": "article",
    "href": "js/articles/vscode-setup.html",
    "title": "Setup VSCode for your project",
    "keywords": "Improve this Doc Setup VSCode for your project In this article we'll focus on configuration and creation of simple node built-in scripts. Warning This article is still a work in progress. Downloading VSCode Before we start, we need downloaded and installed software, so in case you didn't download yet, here you can find all download types for different platforms. By the time I'm writing this article, I'm using Windows portable package. Choose language and model Now, you're left with decision to go with JavaScript or TypeScript. I'll cover configuration for both of them, but if you don't know which one to choose and you're ok with familiarising yourself with additional features that TypeScript implements, you should definitely choose it. Also it'd be good to know if you're creating project for client-side/server-side model or both (will be mentioned later). Preparing folder for project In VSCode click File -> Open Folder, this option will open File Dialog. Create folder in your preferred directory and select folder which you've just created. All project files will be stored in that folder. Caution Always open your project as folder instead of single files. Creating node package Now we'll cover using Terminal feature for executing shell scripts in your project folder. To open it, click View -> Terminal, which will show docked window at the bottom of the editor. Terminal will use default shell in your system (for Windows 10 it's PowerShell). Any possible differences in my shell scripts will be mentioned. Now execute this script in Terminal npm init --yes It will create default package configuration file without asking any questions. You can fill them up later. Now you can install types definitions for your chosen model, which will be used by editor for code validation, auto-completion etc. Check out this document for up-to-date information. If you've chosen TypeScript language for your project, you also need to install TypeScript package npm i -D typescript Creating configuration If you've chosen JavaScript project, your configuration file should be named jsconfig.json and for TypeScript project tsconfig.json . Both are similiar, so if you change your mind later, it won't be hard to switch later. Your configuration file should have content as below { \"compilerOptions\": { \"module\": \"es2015\", \"target\": \"es6\", \"checkJs\": true, \"strict\": true, \"typeRoots\": [ \"./node_modules/@types\", \"./node_modules/@altv\" ], \"outDir\": \"out\" }, \"exclude\": [\"node_modules\"] } Tip Notice typeRoots entry, it's necessary for alt:V types to work without manually defining every package. If you desire to minimise used packages to minimum, use types entry instead. First project script Now we can create our first script, which should be named index.js (as described in package.json ). To test if it all works properly, you can copy this code below import * as alt from \"alt-client\"; alt.setInterval(() => { alt.log(\"This is a self repeating notification every 5 seconds.\"); }, 5000); Warning If you're creating server-side script, you may get error mentioning that module alt-client cannot be found. In this case just change it to alt-server . If all went well, you shouldn't get any errors in your script as well as when typing alt. you should get auto-completion for all available types in that module. Creating resource configuration For this project to be recognised by a language module, we need to create resource configuration file. You can check here for how to proceed.",
    "langs": "powershell json js"
  },
  "js/index.html": {
    "type": "article",
    "href": "js/index.html",
    "title": "alt:V JS module",
    "keywords": "Improve this Doc alt:V JS module This is the documentation for the alt:V JavaScript module to write server gamemodes in JS. Getting started Look into this guide how to create your first server gamemode in JS.",
    "langs": ""
  }
}